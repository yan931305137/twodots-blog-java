-- MySQL dump 10.13  Distrib 8.0.36, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: blog
-- ------------------------------------------------------
-- Server version	8.0.36

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `albums`
--
DROP TABLE IF EXISTS `albums`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `albums` (
  `album_id` int NOT NULL AUTO_INCREMENT COMMENT '相册ID',
  `album_name` varchar(50) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '相册名称',
  `album_cover` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '相册封面',
  `album_introduction` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '相册简介',
  `album_create_time` datetime NOT NULL COMMENT '修改时间',
  `album_level` int NOT NULL COMMENT '相册级别',
  `album_type` int NOT NULL COMMENT '所属一级相册',
  PRIMARY KEY (`album_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `albums`
--

LOCK TABLES `albums` WRITE;
/*!40000 ALTER TABLE `albums` DISABLE KEYS */;
INSERT INTO `albums` VALUES (20,'test1','f7a21370-8a87-4aab-aecf-2e88ad4f9837.jpg','test1','2024-07-06 13:23:38',0,0),(21,'test2','a51a741a-d186-4bca-af3c-c23d2660946c.gif','test1','2024-07-06 13:00:53',0,0),(25,'子','f677ef9c-32bd-4023-9d90-db9f2e65699b.jpg','1','2024-07-06 14:35:40',1,20);
/*!40000 ALTER TABLE `albums` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_comment`
--

DROP TABLE IF EXISTS `blog_comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `blog_comment` (
  `comment_id` int NOT NULL AUTO_INCREMENT COMMENT '评论ID',
  `comment_admin` bit(1) NOT NULL COMMENT '是否是管理员',
  `comment_content` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '评论内容',
  `comment_email` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '邮箱',
  `comment_nickname` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '昵称',
  `comment_create_time` datetime NOT NULL COMMENT '评论时间',
  `blog_id` int NOT NULL COMMENT '博客ID',
  PRIMARY KEY (`comment_id`) USING BTREE,
  KEY `comment_blog_id` (`blog_id`) USING BTREE,
  CONSTRAINT `comment_blog_id` FOREIGN KEY (`blog_id`) REFERENCES `blogs` (`blog_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=29 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_comment`
--

LOCK TABLES `blog_comment` WRITE;
/*!40000 ALTER TABLE `blog_comment` DISABLE KEYS */;
INSERT INTO `blog_comment` VALUES (14,_binary '','非常棒','931305137@qq.com','wsscg','2024-07-06 10:38:33',17),(15,_binary '','还可以','yanjie871@gmail.com','todos','2024-07-06 10:38:56',17),(16,_binary '','你好',NULL,'yj','2024-07-06 10:45:29',17),(17,_binary '','11','11111111111@qq.com','yy','2024-07-06 10:49:16',17),(18,_binary '','嗯嗯 ','3196630659@qq.com','jj','2024-07-06 10:54:25',17),(19,_binary '\0','cpdd','11111111111@qq.com','aa','2024-07-07 09:20:47',14),(20,_binary '\0','cpdd','11111111111@qq.com','aa','2024-07-07 09:21:05',14),(21,_binary '\0','哈哈','11111111111@qq.com','bb','2024-07-07 09:21:22',14),(27,_binary '','雪中送碳啊,太爱了','2039876543@qq.com','无耻之徒','2024-07-07 10:02:32',18),(28,_binary '','nb','931305137@qq.com','wsscg','2024-07-07 13:31:37',18);
/*!40000 ALTER TABLE `blog_comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_tag`
--

DROP TABLE IF EXISTS `blog_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `blog_tag` (
  `blog_id` int NOT NULL COMMENT '博客ID',
  `tag_id` int NOT NULL COMMENT '标签ID',
  KEY `blog_id` (`blog_id`) USING BTREE,
  KEY `tag_id` (`tag_id`) USING BTREE,
  CONSTRAINT `blog_id` FOREIGN KEY (`blog_id`) REFERENCES `blogs` (`blog_id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `tag_id` FOREIGN KEY (`tag_id`) REFERENCES `types` (`type_tag_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_tag`
--

LOCK TABLES `blog_tag` WRITE;
/*!40000 ALTER TABLE `blog_tag` DISABLE KEYS */;
INSERT INTO `blog_tag` VALUES (14,4),(14,1),(15,4),(15,1),(16,4),(16,1),(17,4),(17,1),(18,5);
/*!40000 ALTER TABLE `blog_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blogs`
--

DROP TABLE IF EXISTS `blogs`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `blogs` (
  `blog_id` int NOT NULL AUTO_INCREMENT COMMENT '博客ID',
  `blog_title` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '标题',
  `blog_content` longtext CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '内容',
  `blog_description` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '描述',
  `blog_update_time` date NOT NULL COMMENT '更新时间',
  `blog_views` bigint DEFAULT NULL COMMENT '查看次数',
  `blog_comment` bit(1) NOT NULL COMMENT '是否开启评论',
  `blog_public` bit(1) NOT NULL COMMENT '是否公开',
  `blog_release` bit(1) NOT NULL COMMENT '是否发布',
  `blog_recommend` bit(1) NOT NULL COMMENT '是否推荐',
  `blog_first_img` varchar(500) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '首图地址',
  `user_id` int NOT NULL COMMENT '关联用户ID',
  PRIMARY KEY (`blog_id`) USING BTREE,
  KEY `user_id` (`user_id`) USING BTREE,
  CONSTRAINT `user_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`user_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=32 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blogs`
--

LOCK TABLES `blogs` WRITE;
/*!40000 ALTER TABLE `blogs` DISABLE KEYS */;
INSERT INTO `blogs` VALUES (14,'JAVA 入门','# Java 面向对象编程\r\n\r\n## 第一章 面向对象编程\r\n\r\n### 1.1 基于面向对象编程的开发过程\r\n\r\n基于面向对象的分析 OOA\r\n\r\n基于面向对象的设计 OOD\r\n\r\n基于面向对象的编程 OOP\r\n\r\n基于面向切面的编程\r\n\r\n### 1.2 面向过程和面向对象\r\n\r\n面向过程开发: 将系统按照事务的发展顺序,进行设计,每一个过程都用函数体现(C语言,核心是函数)\r\n\r\n面向对象开发: 减小系统中存在的事务进行归类,按照类别去体现(Java, 核心是对象)\r\n\r\n### 1.3 面向对象的优势\r\n\r\n1.代码复用\r\n\r\n2.不同的分析可以有不同的实现方式\r\n\r\n### 1.4 面向对象的核心\r\n\r\n面向对象的核心是类(对象)\r\n\r\n类: 一类事务的抽象,概括的,统一的说法\r\n\r\n对象: 实际存在的个体, 具体的事物\r\n\r\n类是对象的抽象说法,不占内存,分析代码是抽象说法\r\n\r\n对象是类的具体说法,占内存,需要将类付诸与具体的对象的行为\r\n\r\n注意: 先规划类的具体行为和特征,然后将类的对象创建出来\r\n\r\n### 1.5 类的构成\r\n\r\n#### 1.5.1 属性\r\n\r\n描述一类事物的特征,特征\r\n\r\n#### 1.5.2 方法\r\n\r\n用来描述一类事物 行为,能力,动作\r\n\r\n    类的语法规则:\r\n        控制权限 class 类名{\r\n        //属性,方法\r\n    }\r\n\r\n注意: 1.控制权限 public 公开的\r\n\r\n          2.class 申明类的关键字\r\n\r\n         3.类名: 合法的表示符 首字母大写 含义 不能是关键字\r\n\r\n         4.属性名: 同变量名 (驼峰)\r\n\r\n    属性的语法规则: \r\n        控制权限 数据类型 属性名 = [初始值]\r\n        int 默认值为 0\r\n        \r\n\r\n注意: 1.属性可以给初始值,也可以不给,有默认值 int 0 ,double 0.0 , char \\u0000 , String null, bool false, 引用类型 null,\r\n\r\n         2.控制public\r\n\r\n          3. 数据类型 : 基本类型 + 引用数据类型\r\n\r\n数组,类,接口,枚举,注解\r\n\r\n| 类型  | 含义  | 字节数 | 范围  |\r\n| --- | --- | --- | --- |\r\n| byte | 字节  | 1字节 |     |\r\n| short | 短整型 | 2   |     |\r\n| int | 整型  | 4   |     |\r\n| long | 长整形 | 8   |     |\r\n\r\n| 类型  | 含义  | 字节数 | 范围  |\r\n| --- | --- | --- | --- |\r\n| float | 单精度浮点型 | 4   |     |\r\n| double | 双进度浮点型 | 8   |     |\r\n\r\n| 类型  | 含义  | 字节数 | 范围  |\r\n| --- | --- | --- | --- |\r\n| char | 字符型 |     |     |\r\n\r\n| 类型  | 含义  | 字节数 | 范围  |\r\n| --- | --- | --- | --- |\r\n| boolean | 布尔型 |     |     |\r\n\r\n方法的语法规则:\r\n\r\n    控制权限 [修饰符] 返回类型 方法名(形参类型 形参变量,....){\r\n        方法体;\r\n        [return 返回值]\r\n    }\r\n\r\n注意: 1.控制权限public\r\n\r\n         2.返回类型:\r\n\r\n                1)有返回类型:指定一种类型,八个基本类型\r\n\r\n                2)无返回值:返回类型写void\r\n\r\n         3.方法名: 同变量名\r\n\r\n         4.方法的参数:\r\n\r\n                1)声明参数类型,方法的括号中的参数称之为形参\r\n\r\n                2)方法调用时传入的参数称之为实参\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            System.out.println(\"Hello world!\");\r\n        }\r\n    \r\n        public int sno;\r\n        public String name;\r\n        public int age = 20;\r\n        public float weight;\r\n    \r\n        //    吃饭\r\n        public void eat(){\r\n            System.out.println(name+\"在吃饭\");\r\n        };\r\n    \r\n        //    跑步\r\n        public float run(){\r\n            System.out.println(name+\"在跑步\");\r\n            return 1.1F;\r\n        };\r\n    \r\n        //    求和\r\n        public int calc(int a, int b){\r\n            return  a+b;\r\n        }\r\n    }\r\n\r\n#### 1.5.3 类图\r\n\r\n| 类名  |\r\n| --- |\r\n| + 属性名:  数据类型 |\r\n| + 方法名(参数类型) : 返回值 |\r\n\r\n    public class Player {\r\n    \r\n        public char gender;\r\n        public String name;\r\n        public int level;\r\n    \r\n        public double run(){\r\n            return 1.1;\r\n        };\r\n    \r\n        public void fight (String weapon){\r\n            System.out.println(name+\"用\"+weapon+\"邦邦(๑•̀ㅂ•́)و✧\");\r\n        };\r\n    }\r\n\r\n#### 1.5.4 对象的创建\r\n\r\n类只是从设计的角度去分析,想使用这个类,必须去创建该类的对象,真正的地下的实例(堆中开辟内存)\r\n\r\n    类名 对象名 = new 类名();\r\n\r\n当类创建了对象,在堆中开辟内存,根据类中定义的属性个数决定开辟多大的内存,在堆中去分配\r\n\r\n![d77d8b2692174a778ba5800e6d612963](file:///C:/Users/yj998/OneDrive/%E5%9B%BE%E7%89%87/Typedown/d77d8b26-9217-4a77-8ba5-800e6d612963.png?msec=1720202288051)\r\n\r\n注意 : 每new一次对象,就要去堆中开辟一个新内存\r\n\r\n#### 1.5.5 对象成员的访问\r\n\r\n成员: 属性和方法\r\n\r\n属性的调用:\r\n\r\n    对象名.属性名 //获取\r\n    对象名.属性名 = 值 //赋值\r\n\r\n方法的调用\r\n\r\n    数据类型 返回值 = 对象名.方法名 (实参1 ,实参2); //有返回值的方法\r\n        对象名.方法名(实参1,实参2) //没有返回值\r\n\r\n注意 :     1.当方法中设定了形参,在调用时一定要传入实参\r\n\r\n                    形参: 类中方法声明的参数,形参就是变量\r\n\r\n                    实参: 对象在调用方法时传入的参数,实参就是数值\r\n\r\n                    实参把值赋值给了形参, 形参=实参. 个数一致,类型一致,顺序一致\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            Animal animal = new Animal();\r\n            Player pig = new Player();\r\n            Player monkey = new Player();\r\n    \r\n    \r\n            System.out.println(monkey); //输出为地址\r\n    \r\n            System.out.println(monkey.name); //输出为null\r\n    \r\n            monkey.name= \"孙悟空\";\r\n            System.out.println(monkey.name);\r\n    \r\n            monkey.fight(\"金箍棒\");\r\n    \r\n        }\r\n    }              \r\n\r\n#### 1.5.6 变量的分类\r\n\r\n变量:\r\n\r\n        全局变量(属性)\r\n\r\n        局部变量\r\n\r\n|     | 全局变量 | 局部变量 |\r\n| --- | --- | --- |\r\n| 位置  | 类的里面,方法的外面 | 方法的里面,方法的形参 |\r\n| 权限  | 必须要有权限 | 没有权限 |\r\n| 默认值 | 有默认值 | 没有默认值 |\r\n| 作用范围 | 整个类{} | 所在有语句块 |\r\n| 生命周期 | 对象创建时产生,对象销毁时消失 | 语句块{} |\r\n| 内存  | 堆(对象实例,大块的空间) | 栈(临时的变量存储) |\r\n\r\n注意: 1.当全局变量和局部变量重名时,局部变量会将全局变量覆盖.\r\n\r\n         2.如果在方法中想要调用被覆盖的属性,this.属性 或 该类名.属性\r\n\r\n#### 1.5.7 数组和对象结合\r\n\r\n    public class Student {\r\n        public String name;\r\n    \r\n        public double[] scores;\r\n    \r\n        public double avg(){\r\n            double sum =0;\r\n            for (double score : scores) {\r\n                sum += score;\r\n            }\r\n          return sum/scores.length;\r\n        };\r\n    }\r\n    \r\n    \r\n    public static void main(String[] args) {\r\n            Student student = new Student();\r\n    \r\n            student.name= \"LL\";\r\n            student.scores= new double[]{87, 100, 77};\r\n    \r\n            double avg = student.avg();\r\n            System.out.println(\"平均值:\"+avg);\r\n        }\r\n\r\n2.数组的元素是对象\r\n\r\n对象型数组,数组的每一个元素是对象\r\n\r\n    类[] 数组名 = new 类[];\r\n\r\n    // 无参构造\r\n    public class Goods {\r\n        public int no;\r\n        public String name;\r\n        public double price;\r\n        public int counts;\r\n    }\r\n    \r\n    \r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            Goods[] goods = new Goods[3];\r\n            Scanner scanner = new Scanner(System.in);\r\n    \r\n            for (int i = 0; i < goods.length; i++) {\r\n                goods[i] = new Goods();\r\n                System.out.println(\"-----请输入商品信息-----\");\r\n                System.out.print(\'\\t\'+\"请输入商品名称:\");\r\n                goods[i].name = scanner.next();\r\n                System.out.print(\'\\t\'+\"请输入商品价格:\");\r\n                goods[i].price = scanner.nextDouble();\r\n                System.out.print(\'\\t\'+\"请输入商品编号:\");\r\n                goods[i].no = scanner.nextInt();\r\n                System.out.print(\'\\t\'+\"请输入商品数量:\");\r\n                goods[i].counts = scanner.nextInt();\r\n            }\r\n    \r\n            for (Goods good : goods) {\r\n                System.out.println(\'\\n\'+\"-----商品信息展示-----\");\r\n                System.out.println(\"商品名称:\"+good.name);\r\n                System.out.println(\"商品价格:\"+good.price);\r\n                System.out.println(\"商品编号:\"+good.no);\r\n                System.out.println(\"商品数量:\"+good.counts);\r\n            }\r\n        }\r\n    }\r\n\r\n    public class Goods {\r\n        public int no;\r\n        public String name;\r\n        public double price;\r\n        public int counts;\r\n    \r\n    // alt + inster  全参构造 快捷键\r\n        public Goods(String name, int no, double price, int counts) {\r\n            this.name = name;\r\n            this.no = no;\r\n            this.price = price;\r\n            this.counts = counts;\r\n        }\r\n    }\r\n    \r\n    \r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            Goods[] goods = new Goods[3];\r\n            Scanner scanner = new Scanner(System.in);\r\n            goods[0]= new Goods(\"可乐\",1,3.5,10);\r\n            goods[1]= new Goods(\"雪碧\",2,4.5,100);\r\n            goods[2]= new Goods(\"芬达\",3,5.5,1000);\r\n    \r\n            //        求最高价格\r\n            double max = 0;\r\n            int index = -1;\r\n            for (int i = 0; i < goods.length; i++) {\r\n                if (max < goods[i].price) {\r\n                    max = goods[i].price;\r\n                    index = i;\r\n                }\r\n            }\r\n    \r\n            System.out.println(\"数组下标: \"+index+\'\\n\'+\"最大价格: \"+max);\r\n        }\r\n    }\r\n\r\n    public class Goods {\r\n        public int no;\r\n        public String name;\r\n        public double price;\r\n        public int counts;\r\n    \r\n    \r\n        public Goods(String name, int no, double price, int counts) {\r\n            this.name = name;\r\n            this.no = no;\r\n            this.price = price;\r\n            this.counts = counts;\r\n        }\r\n    }\r\n    \r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            Scanner scanner = new Scanner(System.in);\r\n    \r\n            Goods[] goods = new Goods[3];\r\n            goods[0]= new Goods(\"可乐\",1,3.5,10);\r\n            goods[1]= new Goods(\"雪碧\",2,4.5,100);\r\n            goods[2]= new Goods(\"芬达\",3,5.5,1000);\r\n    \r\n    \r\n            //        查找商品\r\n            System.out.print(\"请输入您需要查找的商品: \");\r\n            int index = -1;\r\n            String s = scanner.next();\r\n            //字符串1.equals(字符串2), 确保字符串1已知, 这样效率高!!!!\r\n            for (int i = 0; i < goods.length; i++) {\r\n                if (goods[i].name.equals(s)) {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n    \r\n            if(index==-1){\r\n                System.out.println(\"商品列表中不存在该商品!\");\r\n            }else{\r\n                System.out.println(goods[index].name+\",\"+goods[index].price);\r\n            }\r\n    \r\n        }\r\n    }\r\n\r\n![44333493673c43cdb20c3a51439e79d7](file:///C:/Users/yj998/OneDrive/%E5%9B%BE%E7%89%87/Typedown/44333493-673c-43cd-b20c-3a51439e79d7.png?msec=1720202288051)\r\n\r\n#### 1.5.8 方法的调用\r\n\r\n##### 1.5.8.1调用方式\r\n\r\n1.对象调用, 类创建出对象后,通过对象调用\r\n\r\n2.类中的方法互相调用\r\n\r\n    public class Main {\r\n        public void a(){\r\n            b();\r\n            System.out.println(\"a\");\r\n        }\r\n        public void b(){\r\n            c();\r\n            System.out.println(\"b\");\r\n        }\r\n    \r\n        public void c(){\r\n            System.out.println(\"c\");\r\n        }\r\n    \r\n        public static void main(String[] args) {\r\n            new Main().a();\r\n        }\r\n    }\r\n\r\n3.递归调用\r\n\r\n方法调用自己,必须要有结束条件,否则会造成死递归,造成堆栈溢出.\r\n\r\n    public class Num {\r\n        //    求阶乘\r\n        public int jc(int n){\r\n            if(n==1){\r\n                return 1;\r\n            }else{\r\n                return jc(n-1)*n;\r\n            }\r\n        }\r\n    \r\n        public static void main(String[] args) {\r\n            Num num = new Num();\r\n            int n = 5;\r\n            int result = num.jc(n);\r\n            System.out.println(n+\"的阶乘: \"+result);\r\n        }\r\n    }\r\n\r\n##### 1.5.8.2 方法的参数个数\r\n\r\n1.方法的重载: 展示方法的多样化\r\n\r\n满足条件:\r\n\r\n    1.方法名相同\r\n    2.方法的参数一定不同:个数不同,类型不同,顺序不同\r\n    3.实参自动调用对应的形参\r\n\r\n    public class Num {\r\n    \r\n        //    两整数求和\r\n        public int sum(int a,int b){\r\n                return a+b;\r\n        }\r\n    \r\n        //      三整数求和\r\n        public int sum (int a,int b,int c){\r\n            return a+b+c;\r\n        }\r\n    \r\n        //      两浮点型数相加\r\n        public double sum(double a, double b){\r\n            return a+b;\r\n        }\r\n    \r\n        public static void main(String[] args) {\r\n            Num num = new Num();\r\n            System.out.println(\"求和结果: \"+num.sum(1,2));\r\n            System.out.println(\"求和结果: \"+num.sum(1,2,3));\r\n            System.out.println(\"求和结果: \"+num.sum(1.1,2.2));\r\n        }\r\n    }\r\n\r\n2.可变长参数\r\n\r\njdk5+\r\n\r\n用于设计方法的时候,不限制参数个数\r\n\r\n    控制权限 返回值 方法名(数据类型...可变长参数变量){\r\n        方法体\r\n    }\r\n\r\n注意: 1.可变长参数一定要放在参数列表最后\r\n\r\n         2.当定义了可变长参数,传递的参数个数可以不定义\r\n\r\n         3.在方法中,将可变长参数作为数组使用\r\n\r\n    public class Num {\r\n        //    整数求和\r\n        public int sum(int ...b){\r\n            int sum = 0;\r\n            for (int i : b) {\r\n                sum+=i;\r\n            }\r\n            return sum;\r\n        }\r\n    \r\n        public static void main(String[] args) {\r\n            Num num = new Num();\r\n            System.out.println(\"求和结果: \"+num.sum(1,2,3,4));\r\n        }\r\n    }\r\n\r\n##### 1.5.8.3 方法调用参数的传递\r\n\r\n当调用方法时,传递实参,将实参的值赋值给形参\r\n\r\n1.基本数据类型: 传递的是数值\r\n\r\n2.引用数据类型: 传递的是地址\r\n\r\n    public class Main {\r\n       public static void change(int a,int[] b, Goods goods){\r\n           a= 10;\r\n           b[0]=9;\r\n           goods.name=\"雪碧\";\r\n       }\r\n    \r\n        public static void main(String[] args) {\r\n            int a= 1;\r\n            int[] b= {1,2,3,4};\r\n            Goods goods = new Goods(\"可乐\",1,5.5,10);\r\n    \r\n            change(a,b,goods);\r\n    \r\n            //基本类型为值传递\r\n            System.out.println(a); \r\n    \r\n            //引用类型为地址传递\r\n            System.out.println(Arrays.toString(b));\r\n            System.out.println(goods.name);\r\n        }\r\n    }\r\n    /*\r\n    输出为\r\n    1\r\n    [9, 2, 3, 4]\r\n    雪碧\r\n    */\r\n    \r\n\r\n### 1.6 构造方法\r\n\r\n构造器 : 类中一种特殊的方法\r\n\r\n作用 : 能够在对象创建时直接给属性赋值(属性的初始化)\r\n\r\n    控制权限 类名(形参列表){\r\n        方法体(给属性赋值)\r\n    }\r\n\r\n注意: 1.没有返回值\r\n\r\n         2.方法名就是类名\r\n\r\n      //全参构造\r\n        public Goods(String name, int no, double price, int counts) {\r\n            this.name = name;\r\n            this.no = no;\r\n            this.price = price;\r\n            this.counts = counts;\r\n        }\r\n    \r\n        //无参构造\r\n        public Goods() {\r\n        }\r\n\r\n构造方法的调用, JVM自动调用\r\n\r\n构造方法使用的时机: new 对象\r\n\r\n构造方法的调用次数: 1\r\n\r\n构造方法分类:\r\n\r\n1.默认构造方法 : 当不定义构造方法时,系统会自动创建一个默认的构造方法(无参构造)\r\n\r\n2.当手动定义了构造方法,默认的无参构造就会被覆盖\r\n\r\n3.构造方法可以实现重载,根据方法的参数不同\r\n\r\n    public class Goods {\r\n        public int no;\r\n        public String name;\r\n        public double price;\r\n        public int counts;\r\n    \r\n    \r\n        //全参构造\r\n        public Goods(String name, int no, double price, int counts) {\r\n            this.name = name;\r\n            this.no = no;\r\n            this.price = price;\r\n            this.counts = counts;\r\n        }\r\n    \r\n        //无参构造\r\n        public Goods() {\r\n        }\r\n    \r\n        // 根据方法参数\r\n        public Goods(int no, String name) {\r\n            this.no = no;\r\n            this.name = name;\r\n        }\r\n    }\r\n\r\n构造方法和普通方法的区别\r\n\r\n|     | 构造方法 | 普通方法 |\r\n| --- | --- | --- |\r\n| 返回类型 | 没有返回类型 | 要有返回类型 |\r\n| 调用方法 | JVM | 对象.方法() |\r\n| 作用  | 属性初始化 | 实现方法内的功能 |\r\n| 时间  | new对象时被调用 |     |\r\n\r\n## 第二章 面向对象的三大特性\r\n\r\n封装性 : 把信息隐藏,数据包装,提高安全\r\n\r\n继承性 : 代码的继承,代码的复用. 一个父类,只能由一个子类\r\n\r\n多态性 : 一个父类可以由多个子类,代码的扩张\r\n\r\n### 2.1 封装性\r\n\r\n#### 2.1.1 什么是封装\r\n\r\n将类中的成员(属性,方法,构造方法),信息隐藏,信息私有化,将类之外的所有地方都不能访问\r\n\r\n#### 2.1.2 作用\r\n\r\n1.保证数据安全\r\n\r\n2.保证数据不被非法的使用\r\n\r\n#### 2.1.3 如何实现封装\r\n\r\n1.需要将封装的成员的控制权限,改为private(私有)\r\n\r\n2.封装的属性必须要提供一组方法,通过 get()获取 ,set()设置 属性值\r\n\r\n    public class Emp {\r\n        private int sno;\r\n        private String name;\r\n        private double sal;\r\n    \r\n        public void setSno(int sno) {\r\n            this.sno = sno;\r\n        }\r\n    \r\n        public void setName(String name) {\r\n            this.name = name;\r\n        }\r\n    \r\n        public void setSal(double sal) {\r\n            this.sal = sal;\r\n        }\r\n    \r\n        public int getSno() {\r\n            return sno;\r\n        }\r\n    \r\n        public String getName() {\r\n            return name;\r\n        }\r\n    \r\n        public double getSal() {\r\n            return sal;\r\n        }\r\n    }\r\n    \r\n    \r\n    public class Main {\r\n       public static void main(String[] args){\r\n          Emp emp = new Emp();\r\n          emp.setName(\"111\");\r\n          emp.setSno(1);\r\n          System.out.println(emp.getName());\r\n          System.out.println(emp.getSno());\r\n       }\r\n    }\r\n    \r\n    \r\n\r\n注意: get方法有返回值\r\n\r\n        set方法没有返回值,有参数\r\n\r\n#### 2.1.4 封装后会怎样\r\n\r\n1.属性赋值的整个过程\r\n\r\n    1) 有默认值\r\n\r\n    2)声明的值\r\n\r\n    3)构造方法\r\n\r\n    4)setXX\r\n\r\n2.方法的封装(构造方法)\r\n\r\n封装方法: 当类中的某些方法不希望外部类去掉用,仅限与类内部使用\r\n\r\n封装构造方法: 单例模式,类不希望被创建对象\r\n\r\n    public class Student {\r\n        public void open(){\r\n            start();\r\n            System.out.println(\"电视打开\");\r\n        }\r\n    \r\n        private void start(){\r\n            System.out.println(\"...零件1\");\r\n            System.out.println(\"...零件2\");\r\n            System.out.println(\"...零件3\");\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n单例模式\r\n\r\n    public class Earth {\r\n        private static Earth earth = new Earth();\r\n    \r\n        private Earth(){\r\n    \r\n        }\r\n    \r\n        public static Earth getEarth(){\r\n            return earth;\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n#### 2.1.5 java源文件的构成\r\n\r\n| 包的声明只有1次 |\r\n| --- |\r\n| 导包的声明有n次 |\r\n| 类的声明有n次 |\r\n\r\n    package 包   //根包.子包\r\n    \r\n    import 导入包\r\n    \r\n    public class 类{\r\n    \r\n    }\r\n\r\n包的作用:\r\n\r\n    1.将逻辑相关的类存放在一起\r\n\r\n    2.限制类的访问,\r\n\r\n注意:\r\n\r\n    1.包名全部小写\r\n\r\n    2.包之间间隔\" . \"\r\n\r\n    3.源文件的首行有效代码\r\n\r\n    import 根包.子包.*     //导入该包所有的资源\r\n    import java.util.Arrays;    //导入java中定义的数组类\r\n    import com.test.Student;    //导入自定义的跨包类 \r\n\r\njava中的API:\r\n\r\njava.lang    核心包(System, String, Math ....)\r\n\r\njava.util     工具包(集合, 日期, Arrays, Scanner)\r\n\r\njava.io        文件包(读写文件)\r\n\r\njava.net    网络\r\n\r\njava.awt    图形化界面\r\n\r\n快捷键: ctrl + shift + o        (java.lang不用手动导,自带)\r\n\r\n### 2.2 继承性\r\n\r\n#### 2.2.1 类和类之间的关系\r\n\r\n1.关联关系(包含)    has a\r\n\r\n2.继承(泛化)            is a\r\n\r\n3.依赖                      use a\r\n\r\n1.关联(包含) A类中包含B类的属性: 1对1 1对n n对n\r\n\r\n    public class A {\r\n    //    1对1\r\n        private B b;\r\n    \r\n    //    1对n\r\n        private C[] c;\r\n    }\r\n    \r\n    class B {\r\n    }\r\n    \r\n    class C {\r\n    //    n对n\r\n        private A[] a;\r\n    }\r\n    \r\n\r\n2.继承: A类满足B类,A类继承B类的代码\r\n\r\n    public class A extends B {\r\n    }\r\n    \r\n    class B {\r\n    }\r\n    \r\n\r\n3.依赖:A类的某个行为依赖与B类去实现\r\n\r\n    public class Student {\r\n        public void goToSchool(Bike bike){\r\n    \r\n        }\r\n    }\r\n    \r\n    public class Bike {\r\n    }\r\n    \r\n    \r\n\r\n    package org.example;\r\n    \r\n    import java.util.Scanner;\r\n    \r\n    public class Main {\r\n        public static void main(String[] args){\r\n            Client[] clients = new Client[2];\r\n            clients[0] = new Client(\"yj\",\"1001\",\"1399999999\",new Account (1001,\"123456\",5000));\r\n            clients[1] = new Client(\"lzy\",\"1002\",\"1399999999\",new Account (1002,\"123456\",4000));\r\n    \r\n            Scanner scanner = new Scanner(System.in);\r\n    \r\n            while (true){\r\n                System.out.println(\"欢迎使用ATM系统:1.登录 2.退出系统\");\r\n                System.out.println(\"请输入操作编号\");\r\n    \r\n                int option= scanner.nextInt();\r\n                switch (option){\r\n                    case 1:\r\n                        System.out.println(\"请输入您的账号:\");\r\n                        int no = scanner.nextInt();\r\n                        int n=-1;\r\n                        for (int i = 0; i < clients.length; i++) {\r\n                            if(clients[i].getA().getAccno() == no){\r\n                                n=i;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (n != -1){\r\n                            System.out.println(\"请输入您的密码:\");\r\n                            String pas = scanner.next();\r\n                            if(clients[n].getA().getPassword().equals(pas)){\r\n                                System.out.println(\"登录成功\");\r\n                                while (true){\r\n                                    System.out.println(\"1.存钱\");\r\n                                    System.out.println(\"2.取钱\");\r\n                                    System.out.println(\"3.查看余额\");\r\n                                    System.out.println(\"4.转账\");\r\n                                    System.out.println(\"5.退出\");\r\n                                    System.out.println(\"请输入操作的编号: \");\r\n                                    int op = scanner.nextInt();\r\n                                    switch (op){\r\n                                        case 1:\r\n                                            System.out.println(\"请输入存款的金额: \");\r\n                                            double money1 = scanner.nextDouble();\r\n                                            if (money1 % 100 == 0 && money1 > 0){\r\n                                                clients[n].getA().setBalance( clients[n].getA().getBalance() + money1);\r\n                                                System.out.println(\"存款\"+money1+\"元成功!\");\r\n                                            }else {\r\n                                                System.out.println(\"金额有误\");\r\n                                            }\r\n                                            break;\r\n                                        case 2:\r\n                                            System.out.println(\"请输入取款的金额: \");\r\n                                            double money2 = scanner.nextDouble();\r\n                                            if (money2 > 0 && money2 <= clients[n].getA().getBalance()){\r\n                                                clients[n].getA().setBalance(clients[n].getA().getBalance()-money2);\r\n                                                System.out.println(\"取款\"+money2+\"元成功!\");\r\n                                            }else {\r\n                                                System.out.println(\"余额不足!\");\r\n                                            }\r\n                                            break;\r\n                                        case 3:\r\n                                            System.out.println(\"当前余额:\"+clients[n].getA().getBalance()+\"元\");\r\n                                            break;\r\n                                        case 4:\r\n                                            System.out.println(\"请输入你要转账的账号:\");\r\n                                            int t = scanner.nextInt();\r\n                                            int n2 = -1;\r\n                                            for (int i = 0; i < clients.length; i++) {\r\n                                                if (clients[i].getA().getAccno() == t){\r\n                                                    n2=i;\r\n                                                    break;\r\n                                                }\r\n                                            }\r\n                                            if (n2 != -1){\r\n                                                System.out.println(\"请输入转账金额:\");\r\n                                                double money3  = scanner.nextDouble();\r\n                                                if(money3<= clients[n].getA().getBalance()){\r\n                                                    clients[n].getA().setBalance(clients[n].getA().getBalance()-money3);\r\n                                                    clients[n2].getA().setBalance(clients[n2].getA().getBalance()+money3);\r\n                                                    System.out.println(\"向\"+clients[n2].getName()+\"转账\"+money3+\"元成功!\");\r\n                                                }else {\r\n                                                    System.out.println(\"余额不足!\");\r\n                                                }\r\n                                            }else {\r\n                                                System.out.println(\"没有查找到该账号!\");\r\n                                            }\r\n                                            break;\r\n                                        case 5:\r\n                                            System.out.println(\"退出系统!\");\r\n                                            break;\r\n                                        default:\r\n                                            System.out.println(\"操作错误!\");\r\n                                    }\r\n                                }\r\n                            }else {\r\n                                System.out.println(\"密码错误!\");\r\n                            }\r\n                        }else {\r\n                            System.out.println(\"账号错误!\");\r\n                        }\r\n                    case 2:\r\n                        System.out.println(\"退出系统!\");\r\n                        System.exit(0);\r\n                  default:\r\n                        System.out.println(\"操作错误!\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    package org.example;\r\n    \r\n    import java.util.Arrays;\r\n    \r\n    public class Client {\r\n        private String name;\r\n        private String card;\r\n        private String tel;\r\n        private Account a;\r\n    \r\n        public Account getA() {\r\n            return a;\r\n        }\r\n    \r\n        public void setA(Account a) {\r\n            this.a = a;\r\n        }\r\n    \r\n        public String getName() {\r\n            return name;\r\n        }\r\n    \r\n        public void setName(String name) {\r\n            this.name = name;\r\n        }\r\n    \r\n        public String getCard() {\r\n            return card;\r\n        }\r\n    \r\n        public void setCard(String card) {\r\n            this.card = card;\r\n        }\r\n    \r\n        public String getTel() {\r\n            return tel;\r\n        }\r\n    \r\n        public void setTel(String tel) {\r\n            this.tel = tel;\r\n        }\r\n    \r\n        public Client(String name, String card, String tel, Account a) {\r\n            this.name = name;\r\n            this.card = card;\r\n            this.tel = tel;\r\n            this.a = a;\r\n        }\r\n    \r\n        @Override\r\n        public String toString() {\r\n            return \"Client{\" +\r\n                    \"name=\'\" + name + \'\\\'\' +\r\n                    \", card=\'\" + card + \'\\\'\' +\r\n                    \", tel=\'\" + tel + \'\\\'\' +\r\n                    \", a=\" + a +\r\n                    \'}\';\r\n        }\r\n    \r\n        public Client() {\r\n            super();\r\n        }\r\n    }\r\n    \r\n    \r\n    package org.example;\r\n    \r\n    public class Account {\r\n        private int accno;\r\n        private String password;\r\n        private double balance;\r\n    \r\n        public Account(int accno, String password, double balance) {\r\n            this.accno = accno;\r\n            this.password = password;\r\n            this.balance = balance;\r\n        }\r\n    \r\n        public Account() {\r\n            super();\r\n        }\r\n    \r\n        public int getAccno() {\r\n            return accno;\r\n        }\r\n    \r\n        public void setAccno(int accno) {\r\n            this.accno = accno;\r\n        }\r\n    \r\n        public String getPassword() {\r\n            return password;\r\n        }\r\n    \r\n        public void setPassword(String password) {\r\n            this.password = password;\r\n        }\r\n    \r\n        public double getBalance() {\r\n            return balance;\r\n        }\r\n    \r\n        public void setBalance(double balance) {\r\n            this.balance = balance;\r\n        }\r\n    \r\n        @Override\r\n        public String toString() {\r\n            return \"Account{\" +\r\n                    \"accno=\" + accno +\r\n                    \", password=\'\" + password + \'\\\'\' +\r\n                    \", balance=\" + balance +\r\n                    \'}\';\r\n        }\r\n    }\r\n    \r\n\r\n#### 2.2.2 什么是继承\r\n\r\n利用现有的类构建新的类的过程就叫做继承\r\n\r\n现有的类: 父类,根类,超类 ,基类\r\n\r\n构建的类: 子类,派生类,衍生类\r\n\r\n子类满足父类的特性,子类相对具体,父类是抽象的\r\n\r\n#### 2.2.3 继承的作用\r\n\r\n代码复用,避免代码的冗余\r\n\r\n#### 2.2.4 如何实现继承\r\n\r\n    控制权限 class 子类 extends 父类{\r\n    \r\n    }\r\n    注意:\r\n        1.控制权限 public 缺省 default 没有权限\r\n        2.子类继承时父类只能由一个\r\n\r\n#### 2.2.5 可以继承的有哪些\r\n\r\n可以继承: 非私有的属性和方法\r\n\r\n不可以继承的: 私有的属性和方法,构造方法\r\n\r\n一次:子类的成员:父类+子类自己的成员\r\n\r\n#### 2.2.6 继承后的问题\r\n\r\n1.类和类之间只存在单继承\r\n\r\n2.继承关系中,越是上层的越抽象,越是下层的越具体\r\n\r\n3.object是所有类的祖先类,顶级点,所有的类都是直接的或间接的继承该类\r\n\r\n4.Java的控制权限\r\n\r\n|     | public | private | protected | 缺省  |\r\n| --- | --- | --- | --- | --- |\r\n| 含义  | 公开  | 私有的 | 受保护的 | 友好的 |\r\n| 范围  | 整个项目 | 当前类 | 同包访问,跨包继承 | 同包访问 |\r\n\r\n#### 2.2.7 方法的重载和重写\r\n\r\n方法的重载:                                                                                      @Overload //(注解)   方法的重写:    方法的覆盖,子类将继承父类的方法进行改造        @Override        原则:    1.方法名必须相同                     2.参数必须相同                     3.返回值类型必须相同                     4.权限不能降低                     5.子类不能比父类抛出的异常更大\r\n\r\n    public class Father {\r\n    \r\n        public void eat(){\r\n            System.out.println(\"爸爸吃\");\r\n        }\r\n    \r\n    \r\n        public void eat(String t){\r\n            System.out.println(\"爸爸吃\"+t);\r\n        }\r\n    \r\n        public int eat(String t, double k){\r\n            return 0;\r\n        }\r\n    }\r\n    \r\n    public class Son extends Father{\r\n    \r\n        //    重写 alt+insert\r\n        @Override\r\n        public void eat(){\r\n            System.out.println(\"孩子吃\");\r\n        }\r\n    \r\n        //    super指向顶层方法\r\n        @Override\r\n        public void eat(String t) {\r\n            //  super.父类的方法\r\n            super.eat(t);\r\n        }\r\n    \r\n        @Override\r\n        public int eat(String t, double k) {\r\n            return super.eat(t, k);\r\n        }\r\n    } \r\n    \r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            Father father = new Father();\r\n            father.eat();\r\n    \r\n            Son son = new Son();\r\n            son.eat();\r\n            son.eat(\"1\");\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n|     | 重载  | 重写  |\r\n| --- | --- | --- |\r\n|     | @Overload | @Override |\r\n| 目的  | 方法多样化 | 子类覆盖父类 |\r\n| 参数  | 参数必须不同 | 参数必须相同 |\r\n| 权限  | 不限制权限 | 不能降低权限 |\r\n| 返回值 | 不限制 | 必须相同 |\r\n| 位置  | 本类,父子类 | 父子类 |\r\n| 次数  | n次  | 1次  |\r\n| 异常  | 不限制异常 | 子类抛出的异常不能比父类抛出的异常大 |\r\n\r\n#### 2.2.8 继承中的构造方法\r\n\r\n1.子类不能继承父类的构造方法,\r\n\r\n2.子类需要手动调用父类的构造方法\r\n\r\n    public 子类(类型 形参变量){\r\n        super(实参,实参)\r\n            //对本类属性赋值\r\n            this\r\n    }\r\n\r\n    public class Father {\r\n    \r\n        private String name;\r\n        private String age;\r\n    \r\n        public Father(String name, String age) {\r\n            this.name = name;\r\n            this.age = age;\r\n      }\r\n    \r\n    } \r\n    \r\n    package org.example;\r\n    \r\n    public class Son extends Father{\r\n        private String tel;\r\n    \r\n        public Son(String name, String age,String tel) {\r\n            super(name, age);\r\n            this.tel= tel;\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n注意:继承中,构造方法执行顺序:祖先类>父类>子类\r\n\r\n当构造方法中第一行没有super关键字,系统默认给我们提供super方法,自动调用父类的构造方法 ,super必须放在方法内第一行\r\n\r\n    public class GrandPa {\r\n        public GrandPa(){\r\n            super();   // super必须写在第一行,可以不用写,系统自动创建并调用\r\n            System.out.println(\"爷爷\");\r\n        }\r\n    } \r\n    \r\n    public class Father extends GrandPa{\r\n        public Father(){\r\n            System.out.println(\"爸爸\");\r\n        }\r\n    }\r\n    public class Son extends Father{\r\n        public Son(){\r\n            System.out.println(\"儿子\");\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n### 2.3 多态性\r\n\r\n#### 2.3.1什么是多态\r\n\r\n一个父类呈现出多个子类的形态,同一个动作展现出不一样的行为\r\n\r\n    向上转型 : 父类 多态对象 = new 子类();\r\n    向下转型 : 子类 多态对象 = (子类) new 父类();         //判断子类和父类之间的关系 instanceof\r\n\r\n向上转型\r\n\r\n    public class Son extends GrandPa{\r\n        @Override\r\n        public void eat() {\r\n            System.out.println(\"小儿子吃\");\r\n        }\r\n    } \r\n    \r\n    public class Father extends GrandPa{\r\n        @Override\r\n        public void eat() {\r\n            System.out.println(\"大儿子吃\");\r\n        }\r\n    } \r\n    \r\n    public class GrandPa {\r\n        public void eat(){\r\n            System.out.println(\"爷爷吃\");\r\n        }\r\n    } \r\n    \r\n     public class Main {\r\n        public static void main(String[] args) {\r\n            GrandPa grandPaSon = new Son();\r\n            grandPaSon.eat();\r\n        }\r\n    } \r\n    \r\n    //结果 : 小儿子吃\r\n\r\n#### 2.3.2 多态的好处\r\n\r\n代码更加灵活,扩展性更加强\r\n\r\n#### 2.3.3 深入分析多态\r\n\r\n栈 = new 堆\r\n\r\n角度: 编译方面\r\n\r\n            向上转型 : 父类 多态对象 = new 子类();            向下转型 : 子类 多态对象 = (子类) new 父类();\r\n\r\n#### 2.3.4 多态对象的访问\r\n\r\n只能访问父类的成员,当前仅当子类覆盖父类方法时 , 执行子类方法\r\n\r\n#### 2.3.5 多态设计的必要条件\r\n\r\n1.继承,一个父类有多个子类\r\n\r\n2.子类必须覆盖父类的方法\r\n\r\n3.对象必须向上转型\r\n\r\n#### 2.3.6 多态的实际应用\r\n\r\n依赖关系的传参\r\n\r\n    public class Developer {\r\n        public void useTool(Usb u){\r\n            u.use();\r\n        }\r\n    }   \r\n    \r\n    public class Usb {\r\n        public String name;\r\n    \r\n        public Usb(String name) {\r\n            this.name = name;\r\n        }\r\n    \r\n        public String getName() {\r\n            return name;\r\n        }\r\n    \r\n        public void setName(String name) {\r\n            this.name = name;\r\n        }\r\n    \r\n        public Usb() {\r\n            super();\r\n        }\r\n    \r\n        public void use(){\r\n            System.out.println(\"usb工作...\");\r\n        }\r\n    }\r\n    \r\n    public class Mouse extends Usb {\r\n        public Mouse(String name) {\r\n            super(name);\r\n        }\r\n    \r\n        public Mouse() {\r\n            super();\r\n        }\r\n    \r\n        @Override\r\n        public void use() {\r\n            System.out.println(getName()+\"使用usb鼠标在工作\");\r\n        }\r\n    }\r\n    \r\n    public class keyBoard extends Usb{\r\n        public keyBoard(String name) {\r\n            super(name);\r\n        }\r\n    \r\n        public keyBoard() {\r\n            super();\r\n        }\r\n    \r\n        @Override\r\n        public void use() {\r\n            System.out.println(getName()+\"使用usb键盘工作\");\r\n        }\r\n    }\r\n    \r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            Developer developer = new Developer();\r\n            developer.useTool(new keyBoard(\"yj\"));   // 相当于 Usb usb = new keyBoard(\"yj\"); developer.useTool(usb);\r\n        }\r\n    }\r\n    \r\n    // 结果 : yj使用usb键盘工作\r\n\r\n#### 2.3.7 instanceof向下转型\r\n\r\n用于某个对象是哪一个类型\r\n\r\n    对象 instanceof 类型(类/接口)\r\n\r\n1.返回的是bollean true(对象就是类型,对象的子类类型) false不是这个类型\r\n\r\n2.如果对象和类型没有任何关系\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            Cat cat = new Cat();\r\n            Tiger tiger = new Tiger();\r\n    \r\n            Animal animal = new Animal();\r\n    \r\n    \r\n    \r\n            System.out.println(cat instanceof Cat);  //cat对象就是猫类型\r\n    \r\n            System.out.println(cat instanceof Animal); //cat对象是Animal子对象\r\n    \r\n    //        System.out.println(cat instanceof Tiger); //出现红色波浪线表示编译错误\r\n    \r\n            System.out.println(animal instanceof Cat); //动物对象不一定是猫\r\n    \r\n        }\r\n    }\r\n    \r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            Animal animal = new Animal();\r\n            animal.eat();\r\n    \r\n            // 永假,类型不匹配,防止乱搞赋值\r\n            if (animal instanceof Tiger){\r\n                Tiger tiger = (Tiger) animal;\r\n                tiger.eat();\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n## 第三章 面向对象的高级特性\r\n\r\n### 3.1 abstract\r\n\r\n#### 3.1.1 什么是抽象\r\n\r\n抽象的,难以描述清楚的,比较笼统的,概念模糊的\r\n\r\n#### 3.1.2 abstract可以修饰哪些\r\n\r\n1.类 (变为 抽象类)\r\n\r\n    public abstract class Test(){\r\n    \r\n    }\r\n\r\n2.方法 抽象方法\r\n\r\n    控制权限 abstract 返回类型 方法名(形参);\r\n\r\n#### 3.1.3 抽象类的特征\r\n\r\n1.抽象类一般作为父类,抽象类不能实例化(不能new)\r\n\r\n2.抽象父类强制要求必须有子类继承,子类将器描述清楚\r\n\r\n3.子类继承抽象父类之后,必须重写父类中的所有抽象方法,否则该类就会变为抽象类\r\n\r\n4.抽象类中不一定都是抽象方法,也可以是非抽象 方法,有抽象类的类必须是抽象类\r\n\r\n5.抽象有构造方法,不能有new\r\n\r\n    public abstract class Fly {\r\n        private String name;\r\n    \r\n        public  abstract void fly();\r\n    \r\n        public String getName() {\r\n            return name;\r\n        }\r\n    \r\n        public void setName(String name) {\r\n            this.name = name;\r\n        }\r\n    \r\n        // 供子类调用,脱离虚拟机的调用\r\n        public Fly(){\r\n    \r\n        }\r\n    }  \r\n    \r\n     public class Bird extends Fly{\r\n        @Override\r\n        public void fly() {\r\n            System.out.println(\"鸟飞\");\r\n        }\r\n    } \r\n    \r\n    public class Plane extends Fly{\r\n        @Override\r\n        public void fly() {\r\n            System.out.println(\"飞机飞\");\r\n        }\r\n    \r\n    }\r\n    \r\n    public abstract class Main {\r\n        public static void main(String[] args) {\r\n    //        多态\r\n            Fly fly = new Plane();\r\n            fly.fly();\r\n        }\r\n    \r\n        public abstract void A();\r\n    }\r\n    \r\n\r\n#### 3.1.4 抽象方法的特征\r\n\r\n1、无法描述的行为，一定不能有方法体 {}\r\n\r\n2、包含抽象方法的类一定是抽象类。\r\n\r\n### 3.2 static\r\n\r\n#### 3.2.1 什么是static\r\n\r\n静态的,属于类的,不再属于某一个对象\r\n\r\n#### 3.2.2 static可以修饰什么\r\n\r\n属性 方法 内部类\r\n\r\n#### 3.2.3 静态属性\r\n\r\n加static的属性 : 静态属性,类属性,是所有对象的共享资源,不再单独属于某一个对像.\r\n\r\n不加static: 实例属性,是每一个对象共享资源\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            Person person = new Person();\r\n            System.out.println(person.getName());\r\n            System.out.println(person.getAge());\r\n            System.out.println(Person.type);\r\n        }\r\n    }\r\n    \r\n    public class Person {\r\n        private  String name;\r\n        private int age;\r\n        public static String type= \"灵长类\";\r\n    \r\n        public String getName() {\r\n            return name;\r\n        }\r\n    \r\n        public void setName(String name) {\r\n            this.name = name;\r\n        }\r\n    \r\n        public int getAge() {\r\n            return age;\r\n        }\r\n    \r\n        public void setAge(int age) {\r\n            this.age = age;\r\n        }\r\n    \r\n        public static String getType() {\r\n            return type;\r\n        }\r\n    \r\n        public static void setType(String type) {\r\n            Person.type = type;\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n不加static时在栈中,加了static之后在静态区中,当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。\r\n\r\n    public class Main {\r\n        public int i =10;\r\n        public static int j =20;\r\n        public Main(){\r\n            i++;\r\n            j++;\r\n        }\r\n    \r\n        public static void main(String[] args) {\r\n            Main main = new Main();\r\n            System.out.println(main.i+\",\"+main.j);  //11,21\r\n    \r\n            Main main2 = new Main();\r\n            System.out.println(main2.i+\",\"+main2.j);    //11,22\r\n        }\r\n    }\r\n\r\n静态属性和实例的区别\r\n\r\n|     | 静态属性 | 实例属性 |\r\n| --- | --- | --- |\r\n| 含义  | 属于类,对象的共享资源 | 每个对象独有 |\r\n| 个数  | 一个类只拷贝一份 | n份  |\r\n| 内存分配 | 静态区 | 堆   |\r\n| 初始化 | 类加载时(类使用之前) | 创建对象 |\r\n| 调用  | 类.静态属性 / 对象.静态属性 | 对象.实例属性 |\r\n\r\n3.2.4 静态方法\r\n\r\n1.静态方法只能调用静态的方法或属性 (只能在静态之间调用)\r\n\r\n2.当静态方法就是要调用非静态的对象,只能创建对象\r\n\r\n3.实例方法可以调用静态方法\r\n\r\n4.类名.静态方法() / 对象.静态方法()\r\n\r\n    public class Main {\r\n        public int i =10;\r\n        public static int j =20;\r\n    \r\n        public static void t1(){\r\n            System.out.println(j);\r\n            Main main = new Main();\r\n            System.out.println(main.i);\r\n            main.t3();\r\n        }\r\n    \r\n        public static void t2(){\r\n    \r\n        }\r\n    \r\n        public void t3(){\r\n            t1();\r\n            t2();\r\n            System.out.println(i);\r\n            System.out.println(j);\r\n        }\r\n    \r\n        public static void main(String[] args) {\r\n    \r\n        }\r\n    } \r\n\r\n#### 3.2.5 静态代码块\r\n\r\n静态代码块用来初始化静态成员\r\n\r\n    static{\r\n    \r\n    }\r\n    \r\n    //实代码块例\r\n    {\r\n    \r\n    }\r\n\r\n静态代码块注意:\r\n\r\n        1.位置 : 与构造方法同级\r\n\r\n        2.个数 : 可以有多个,按照顺序执行\r\n\r\n        3.时机 : 类加载时\r\n\r\n        4.次数 : 1次\r\n\r\n        5.顺序 : 静态 > 实例 > 构造\r\n\r\n    public class Main {\r\n        public static int a;\r\n        public int b;\r\n    \r\n        static {\r\n            a = 20;\r\n            System.out.println(\"静态\");\r\n        }\r\n    \r\n        {\r\n            System.out.println(\"实例\");\r\n        }\r\n    \r\n        public Main(){\r\n            System.out.println(\"构造\");\r\n        }\r\n    \r\n        public static void main(String[] args) {\r\n            System.out.println(Main.a);\r\n        }\r\n    }\r\n    \r\n    /*\r\n    结果:\r\n    20        \r\n    静态                  \r\n    */\r\n    \r\n    \r\n\r\n### 3.3 final\r\n\r\n#### 3.3.1 什么是final\r\n\r\n最后的,最终的\r\n\r\n#### 3.3.2 final修饰什么\r\n\r\n变量: 全局变量, 局部变量\r\n\r\n常量:\r\n\r\n方法\r\n\r\n类\r\n\r\n    public final class Main {\r\n        public final static int a = 10;\r\n    \r\n        public final int b = 10;\r\n    \r\n        public static void main(String[] args) {\r\n            System.out.println(Main.a);\r\n        }\r\n    }\r\n    \r\n\r\n#### 3.3.3 final修饰内容的特点\r\n\r\nfinal修饰变量:常量,已经定义不能修改; final修饰的属性必须设置初始值,不能使用默认值\r\n\r\nfinal修饰方法:不能被重写\r\n\r\nfinal修饰类:不能有子类,最后的类\r\n\r\n### 3.4 修饰符共用问题\r\n\r\nabstract 类 方法\r\n\r\nstatic 属性 方法\r\n\r\nfinal 变量 方法 类\r\n\r\n不能混合使用\r\n\r\nabstract 和 static\r\n\r\nabstract 和 final\r\n\r\nabstract 和 private\r\n\r\n可以混用\r\n\r\nstatic 和 final 可以一起修饰属性和方法,不限制顺序\r\n\r\n注意:如果用final修饰变量,变量名必须要大写,全大写\r\n\r\n## 第四章 接口\r\n\r\n### 4.1 接口的意义\r\n\r\n当一个子类继承了父类之后,不能具备其它父类的特性,接口可以使类具备多种特性\r\n\r\n目的是解决继承的单继承的问题\r\n\r\n接口作为引用数据类型,抽象概念,只能定义方法声明\r\n\r\n注意:开发中,设计和实现要分开,接口是设计层面\r\n\r\n### 4.2 接口的定义\r\n\r\n    控制权限 interface 接口名字{\r\n    \r\n    }\r\n\r\n注意\r\n\r\n1.控制权限 public 缺省\r\n\r\n2.关键字 interface\r\n\r\n3.接口名 同类名\r\n\r\n### 4.3 接口实现\r\n\r\n    控制权限 class 实现类 extends 父类 implements 接口1,接口2..{\r\n    \r\n    }\r\n\r\n注意: 单继承,多实现,\r\n\r\n    public class Iron {\r\n    \r\n    } \r\n    \r\n    public class Tank extends Iron implements Iweapon,IVehicles{\r\n    \r\n    }\r\n    \r\n    public abstract class UFO implements Iweapon,IVehicles{\r\n    \r\n    } \r\n    \r\n    public interface Iweapon {\r\n    \r\n    } \r\n    \r\n    public interface IVehicles {\r\n    \r\n    }\r\n    \r\n\r\n### 4.4 接口中的成员\r\n\r\n    属性: 公开的静态常量 public static final = 初始值\r\n    方法: 公开的抽象方法 public abstract 返回值 方法名(参数)\r\n\r\n注意:\r\n\r\n1.接口中属性和方法的修饰全部都是默认,即使不写系统也会默认是该类型\r\n\r\n2.接口中没有构造方法,肯定不能实例化\r\n\r\n    public interface Iweapon {\r\n        public static final int POWER =10;\r\n        int P = 10;\r\n    \r\n        public abstract void fire();\r\n        void f();\r\n    }\r\n\r\n### 4.5 接口的实现\r\n\r\n1.覆盖接口中的抽象方法\r\n\r\n    public class Tank extends Iron implements Iweapon,IVehicles{\r\n    \r\n        @Override\r\n        public void fire() {\r\n            System.out.println(\"开炮\");\r\n        }\r\n    \r\n        @Override\r\n        public void f() {\r\n    \r\n        }\r\n    \r\n        @Override\r\n        public String fix(int hour) {\r\n            System.out.println(\"保养\"+hour+\"小时\");\r\n            return \"\";\r\n        }\r\n    }\r\n    \r\n\r\n2.接口中的常量\r\n\r\n接口名.属性 不能修改\r\n\r\n3.接口中的多态\r\n\r\n    接口类型 多态类型 = new 实现类();\r\n\r\n    public final class Main {\r\n        public static void main(String[] args) {\r\n            Iweapon iweapon = new Tank();\r\n            iweapon.fire();\r\n        }\r\n    }\r\n    \r\n    public class Tank extends Iron implements Iweapon,IVehicles{\r\n    \r\n        @Override\r\n        public void fire() {\r\n            System.out.println(\"开炮\");\r\n        }\r\n    \r\n        @Override\r\n        public void f() {\r\n    \r\n        }\r\n    \r\n        @Override\r\n        public String fix(int hour) {\r\n            System.out.println(\"保养\"+hour+\"小时\");\r\n            return \"\";\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n### 4.6 类和接口的关系\r\n\r\n| 关系  | 继承角度 |     | 关键字 |     |\r\n| --- | --- | --- | --- | --- |\r\n| 类和类 | 单继承 | 一个父类可以有多个子类 | extends |     |\r\n| 类和接口 | 多实现 | 接口多个实现类 | implements |     |\r\n| 接口和接口 | 多继承 | 父接口可以有多个子接口,子接口可以继承多个父接口 | extends |     |\r\n|     |     |     |     |     |\r\n\r\n    public interface  UFO extends Iweapon, IVehicles {\r\n    \r\n    }\r\n    \r\n\r\n### 4.7 抽象类和接口的区别\r\n\r\n|     | 抽象类 | 接口  |\r\n| --- | --- | --- |\r\n| 定义  | abstract class | interface |\r\n| 属性  | 自定义 private | public static final |\r\n| 方法  | 自定义 (抽象+非抽象) | public abstract |\r\n| 构造  | 有   | 无   |\r\n| 与类关系 | 单继承 | 多实现 |\r\n\r\njdk8+ : 接口允许定义非抽象方法\r\n\r\n    public interface IVehicles {\r\n        public default void test(){\r\n    \r\n        }\r\n    }\r\n    \r\n\r\n## 第五章 枚举\r\n\r\n### 5.1 枚举的意义\r\n\r\n枚举表示列举,用于一组固定的离散值\r\n\r\n### 5.2 枚举的作用\r\n\r\n1.代码的安全性更加高,不会被非法的调用\r\n\r\n2.降低代码的耦合度\r\n\r\n3.代码的可读性提高,\r\n\r\n### 5.3 枚举的声明\r\n\r\n    控制权限 enum 枚举名{\r\n    \r\n    }\r\n    控制权限 public 缺省\r\n        枚举名 :首字母大写, 合法的标识符\r\n\r\n### 5.4 枚举的成员\r\n\r\n    控制权限 enum 枚举名{\r\n        枚举常量...\r\n    }\r\n\r\n### 5.5 枚举成员的调用\r\n\r\n    枚举名.枚举常量\r\n\r\n    \r\n    public enum Light {\r\n        RED,GREEN,YELLOW\r\n    } \r\n    \r\n    public final class Main {\r\n        public static void main(String[] args) {\r\n            System.out.println(Light.YELLOW);\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n### 5.6 工厂模式\r\n\r\n单例模式: 返回一个对象实例\r\n\r\n    \r\n    public class Singleton {\r\n        private static Singleton ins = new Singleton();\r\n    \r\n        public static Singleton getSingleton(){\r\n            return ins;\r\n        }\r\n    } \r\n    \r\n    public final class Main {\r\n        public static void main(String[] args) {\r\n            Singleton s1 = new Singleton();\r\n            Singleton s2 = new Singleton();\r\n    \r\n            System.out.println(s1 == s1);        //因为Singleton 里面 是私有静态的,所以为true\r\n        }\r\n    }        \r\n    \r\n    \r\n\r\n静态工厂模式\r\n\r\n    public final class Main {\r\n        public static void main(String[] args) {\r\n           Ishoe ishoe = ShoesFacyory.make(ShoeType.ANT);\r\n           ishoe.info();\r\n        }\r\n    } \r\n    \r\n    public interface Ishoe {\r\n        // 鞋子的特征\r\n        void info();\r\n    }\r\n    \r\n    public class ShoesFacyory {\r\n        private static Ishoe ishoe;\r\n    \r\n        public static Ishoe make(ShoeType type){\r\n            switch (type){\r\n                case ANT:\r\n                    ishoe = new Ant();\r\n                    break;\r\n                case NIKE:\r\n                    ishoe = new Nike();\r\n                    break;\r\n                case ADIDAS:\r\n                    ishoe = new Adidas();\r\n                    break;\r\n                default:break;\r\n            }\r\n            return ishoe;\r\n        }\r\n    } \r\n    \r\n    public class Nike implements Ishoe {\r\n        @Override\r\n        public void info() {\r\n            System.out.println(\"耐克\");\r\n        }\r\n    }\r\n    \r\n    public class Adidas implements Ishoe{\r\n        @Override\r\n        public void info() {\r\n            System.out.println(\"阿迪达斯\");\r\n        }\r\n    }\r\n    \r\n    public class Ant implements Ishoe{\r\n        @Override\r\n        public void info() {\r\n            System.out.println(\"安踏\");\r\n        }\r\n    }\r\n\r\n## 第六章 内部类\r\n\r\n### 6.1 什么是内部类\r\n\r\n定义在类里面的类,就是内部类,外面的外部类\r\n\r\n### 6.2 实例内部类\r\n\r\n1.静态的内部类\r\n\r\n2.实例的内部类\r\n\r\n3.局部的内部类\r\n\r\n    public class Outer {\r\n    \r\n        //  静态内部类\r\n        public static class Inner{\r\n            public int a = 10;\r\n            public static  int b= 20;\r\n        }\r\n    \r\n        //  实例内部类\r\n        public class Inner2{\r\n            public int a = 20;\r\n        }\r\n    \r\n        public void test(){\r\n    \r\n            //  局部内部类\r\n            class Inner{\r\n    \r\n            }\r\n    \r\n        }\r\n    }\r\n\r\n静态内部类的调用\r\n\r\n    外部类.静态内部类\r\n\r\n    public final class Main {\r\n        public static void main(String[] args) {\r\n           Outer.Inner inner = new Outer.Inner();\r\n            System.out.println(inner.a);\r\n            System.out.println(Outer.Inner.b);\r\n        }\r\n    }\r\n    \r\n\r\n实例内部类的调用\r\n\r\n    new 外部类().new 实例内部类()\r\n\r\n    public final class Main {\r\n        public static void main(String[] args) {\r\n           Outer.Inner2 outer = new Outer().new Inner2();\r\n        }\r\n    }\r\n\r\n局部内部类\r\n\r\n看方法,通过外部类调用\r\n\r\n    public class Outer {\r\n    \r\n        //  静态内部类\r\n        public static class Inner{\r\n            public int a = 10;\r\n            public static  int b= 20;\r\n        }\r\n    \r\n        //  实例内部类\r\n        public class Inner2{\r\n            public int a = 20;\r\n        }\r\n    \r\n        public void test(){\r\n    \r\n            //  局部内部类\r\n            class Inner3{\r\n                int a = 50;\r\n                public void test2(){\r\n                    System.out.println(\"局部内部类\");\r\n                }\r\n            }\r\n            Inner3 inner3 = new Inner3();\r\n            System.out.println(inner3.a);\r\n            inner3.test2();\r\n        }\r\n    }\r\n    \r\n    public final class Main {\r\n        public static void main(String[] args) {\r\n           Outer outer = new Outer();\r\n           outer.test();\r\n        }\r\n    }\r\n\r\n### 6.3 匿名内部类\r\n\r\n1.该内部类没有名字\r\n\r\n2.以上三种内部类都是看可以匿名的\r\n\r\n    抽象父类 变量名 = new 抽象父类(){\r\n    \r\n    }\r\n    接口 变量名 = new 接口(){\r\n    \r\n    }\r\n\r\n    public final class Main {\r\n        public static void main(String[] args) {\r\n            new Ishoe() {\r\n                @Override\r\n                public void info() {\r\n                    System.out.println(\"....\");\r\n                }\r\n            }.info();\r\n    \r\n            Ishoe ishoe = ()-> System.out.println(\"...\");\r\n            ishoe.info();\r\n    \r\n    \r\n            ((Ishoe) () -> System.out.println(\"....\")).info();\r\n        }\r\n    }','java 从入门到入土','2024-07-06',8,_binary '',_binary '',_binary '',_binary '','ee44582d-7626-4cce-a75d-22a587ef122b.jpg',1),(15,'JAVA API','# Java API(程序接口)\r\n\r\n## 第一章 概述\r\n\r\napi :\r\n\r\n1.java.lang : 异常类,String ,Math, StringBuffer ,Object ,Class反射\r\n\r\n2.util : 日期类, 日期转化, 精度处理, 集合...\r\n\r\n3.io 文件的读取\r\n\r\n4.net\r\n\r\n5.多线程 java.lang 重点\r\n\r\n6.图形窗口 awt\r\n\r\n7.jdk8+新特性: stream流,API\r\n\r\n## 第二章 异常\r\n\r\n### 2.1 什么是异常\r\n\r\n程序编译或运行中出现的问题,统称为异常,\r\n\r\n异常: 程序异常Exception    错误Error\r\n\r\n异常的根类 Throwable\r\n\r\n    程序异常类: Exception 由于程序员疏忽,设计不合理导致的异常,可以处理\r\n\r\n    程序错误类: Error 程序中出现的致命问题,虚拟机奔溃,堆栈溢出,不需要再程序中解决\r\n\r\n### 2.2 Exception的分类\r\n\r\n1.编译时异常: 在编译是发生的异常,如果不解决则无法编译\r\n\r\n例如:\r\n\r\n    io异常(IOException)    ,     数据库异常(SQLException)    ,    文件未找到异常(FileNotFoundException)\r\n\r\n2.运行时异常: 编译时没有问题,运行时抛出异常(RunTimeException)\r\n\r\n例如\r\n\r\n| 异常类 | 含义  | 示例  |\r\n| --- | --- | --- |\r\n| ArrayIndexOutOfBoundsException | 数组下标越界异常 | int[] a= new int[4]; |\r\n| System.out.println(a[4]); |     |     |\r\n| NullPointerException | 空引用异常 | String s = null; |\r\n| System.out.println(s.length()); |     |     |\r\n| ArithmaticException | 数字异常 | System.out.println(10/0); |\r\n| ClassCastExcepton | 类型转换异常 | 向下转型 |\r\n| NumberFormatExceptionn | 数字转化异常 | System.out.println(Integer.parseInt(\"a\")); |\r\n| IllegalArgumentException | 非法参数异常 |     |\r\n\r\n### 2.3 出现异常后的反应\r\n\r\n1.系统打印错误信息\r\n\r\n2.程序终止\r\n\r\n3.分配对象信息的资源不变\r\n\r\n### 2.4 异常捕获机制\r\n\r\n异常的处理: try-catch-finally\r\n\r\n语法规则\r\n\r\n    try{\r\n        //代码监视器,有可能发生问题的代码放进去\r\n    }catch(异常类型 变量名){\r\n        //异常捕获,处理问题\r\n    }catch(..){\r\n    \r\n    }finally{\r\n        //清理块,无条件执行的语句块\r\n    }\r\n\r\n注意:\r\n\r\n1.try: 不可以单独出现,需要配合catch(处理异常) 或 finally\r\n\r\n2.catch 可以捕获不同类型异常,类似于分支语句,n选1,类型不能重复\r\n\r\n3.因此 catch(Exception e) 放到catch最后,用总异常兜底\r\n\r\n4.finally : 可以写也可以i不写,无条件执行, return 退出虚拟机\r\n\r\ncatch 特点:\r\n\r\n            1)优先抓取细节上的异常,再到大的异常, 从子类异常到父类异常\r\n\r\n            2)try和finally同时出现时,catch可以不写\r\n\r\n    public final class Main {\r\n        public static void main(String[] args) {\r\n    \r\n            try {\r\n                System.out.println(\"start\");\r\n                System.out.println(Integer.parseInt(\"a\"));\r\n            }catch (NumberFormatException numberFormatException){\r\n                System.out.println(\"发生数字转化异常\");\r\n            }finally {\r\n                System.out.println(\"无条件执行\");\r\n            }\r\n        }\r\n    }\r\n\r\n    public final class Main {\r\n        public static void main(String[] args) {\r\n            try {\r\n                System.out.println(\"start\");\r\n                System.out.println(Integer.parseInt(\"a\"));\r\n            }catch (NumberFormatException numberFormatException){\r\n                System.out.println(\"发生数字转化异常\");\r\n                return;\r\n            }finally {\r\n                System.out.println(\"无条件执行\");\r\n            }\r\n            System.out.println(\"结束\");\r\n        }\r\n    }\r\n    \r\n    // 先执行finally后执行return\r\n\r\n    public final class Main {\r\n        public static void main(String[] args) {\r\n            try {\r\n                System.out.println(\"start\");\r\n                System.out.println(Integer.parseInt(\"a\"));\r\n            }catch (NumberFormatException numberFormatException){\r\n                System.out.println(\"发生数字转化异常\");\r\n                System.exit(0);\r\n            }finally {\r\n                System.out.println(\"无条件执行\");\r\n            }\r\n            System.out.println(\"结束\");\r\n        }\r\n    }  \r\n    \r\n    //如果是退出虚拟及则无条件退出,不会执行finally\r\n\r\n    public final class Main {\r\n        public static void main(String[] args) {\r\n            try {\r\n                System.out.println(\"start\");\r\n                System.out.println(Integer.parseInt(\"a\"));\r\n                return;\r\n            }catch (NumberFormatException numberFormatException){\r\n                System.out.println(\"发生数字转化异常\");\r\n            }finally {\r\n                System.out.println(\"无条件执行\");\r\n            }\r\n            System.out.println(\"结束\");\r\n        }\r\n    } \r\n    \r\n    //如果return在try里面前面出现异常根本并不会执行到return,所以后面的都会执行\r\n\r\n### 2.5 异常抛出\r\n\r\nthrow 和 throws\r\n\r\n#### 2.5.1 throws\r\n\r\n当方法内有异常发生,不解决,或者难以解决,将方法内的异常向外抛出,使用throws\r\n\r\n语法\r\n\r\n    控制权限 返回值 方法名 (参数类型 参数变量) throws 异常类型1, 异常类型2..{\r\n    \r\n    } \r\n\r\n注意:\r\n\r\n    1.方法的异常抛给方法的调用,调用者必须要解决或者向上抛,直到抛到虚拟机,可能会造成崩溃,所以异常要及时解决\r\n\r\n    public class TestThrows {\r\n        public static void test1() throws ArithmeticException{\r\n            System.out.println(10/0);\r\n        }\r\n    \r\n        public static void main(String[] args) {\r\n            try {\r\n                test1();\r\n            }catch (Exception e){\r\n                System.out.println(\"发生异常: \"+e);\r\n                e.printStackTrace();          \r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n2.方法重写, 子类不能抛出比父类更大的异常\r\n\r\n3.一般都是编译时异常\r\n\r\n#### 2.5.2 throw\r\n\r\n当程序员需要手动制造一个异常,并且抛出去\r\n\r\n语法:\r\n\r\n    1.创建一个异常对象\r\n        Exception 对象名 = new Exception(\"异常问题\");\r\n    2.throw 对象名\r\n\r\n    public class TestThrow {\r\n        public static void main(String[] args) {\r\n            checkAge(9);\r\n            System.out.println(\"继续\");\r\n            checkAge(300);\r\n            System.out.println(\"结束\");\r\n        }\r\n    \r\n        public static void checkAge(int age){\r\n            if(age>0 && age< 200){\r\n                System.out.println(\"年龄合法\");\r\n            }else {\r\n                throw new RuntimeException(\"年龄不合法\");\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n注意 : 运行时异常不用向上抛,而编译时异常需要向上抛\r\n\r\n| throws | throw |\r\n| --- | --- |\r\n| 方法向外自动抛出异常 | 手动创建异常抛出 |\r\n| 异常类 | 异常对象 |\r\n| 方法的后面 | 方法的里面 |\r\n\r\n### 2.6 自定义异常\r\n\r\n可以自己构建一个异常类型,需要继承异常父类 RunTimeException\r\n\r\n## 第三章 Math\r\n\r\nMath 类包含了用于执行数学运算的方法\r\n\r\n注意:math时final修饰的类,\r\n\r\n| 属性  |     |     |\r\n| --- | --- | --- |\r\n| PI  | 圆周率 |     |\r\n| E   | 自然底数 |     |\r\n\r\n方法 :\r\n\r\n| 方法  | 含义  | 返回值或参数 |\r\n| --- | --- | --- |\r\n| random() | 随机数 | ((max - min + 1) * Math.random() + min) |\r\n| ceil(double) | 向上取整 | 获得比当前参数稍微大的整数,如果参数是整数返回自己 |\r\n| floor(double) | 向下取整 | 获得比当前稍微小的整数,如果参数是整数返回自己 |\r\n| round(double) | 四舍五入 | 返回四舍五入的结果(整数) |\r\n| sqrt(double) | 开平方根 |     |\r\n| pow(a,b) | a的b次幂 | b个a相乘 |\r\n\r\n验证码\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            char []captcha = new char[4];\r\n    \r\n            for (int i = 0; i < captcha.length; i++) {\r\n                captcha[i] = (char) ((90-65+1)*Math.random()+65);\r\n                for (int j = 0; j < i; j++) {\r\n                    if (captcha[i] == captcha[j]){\r\n                        i--;\r\n                    }\r\n                }\r\n            }\r\n            System.out.println(Arrays.toString(captcha));\r\n        }\r\n    }\r\n\r\n猜数字\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            Scanner scanner = new Scanner(System.in);\r\n            int num =(int)((100- 50+1)*Math.random()+1);\r\n            int s=50, e=100, m;\r\n            for (int i = 0; i < 5; i++) {\r\n                if(num<50){\r\n                    System.out.println(\"第\"+(i+1)+\"次机会,请输入你猜测的数字:\");\r\n                    m= scanner.nextInt();\r\n                    if(num < m){\r\n                        System.out.println(\"猜大了\");\r\n                        s= m;\r\n                    }else if (num>m){\r\n                        System.out.println(\"猜小了\");\r\n                    }else {\r\n                        System.out.println(\"WIN\");\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            System.out.println(\"Loser,结果为:\"+num);\r\n        }\r\n    }\r\n\r\n## 第四课 String 和 StringBuilder\r\n\r\n### 4.1 String\r\n\r\n不可变字符串,一经定义不可改变,\r\n\r\n注意,字符串对象和字符串常量,都被认为是对象型\r\n\r\n    构造方法:\r\n        new String();\r\n        new Steing(\"aaa\")\r\n        new String(StringBuilder sb1); // 将StringBuilder转为String类型\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            String s1 = new String(\"aaa\");\r\n            String s2 = new String(\"aaa\");\r\n    \r\n            System.out.println(s1 == s2);\r\n    \r\n            System.out.println(s1.equals(s2));\r\n    \r\n            String s3 = \"abc\";\r\n            String s4 = \"abc\";\r\n            System.out.println(s3==s4);\r\n        }\r\n    }\r\n    \r\n    /*\r\n    false\r\n    true\r\n    true\r\n    */\r\n\r\njava堆 (javaHelp) : 是java虚拟机里面最大的一块内存存储区,被所有线程共享,在虚拟机启动时创建,用来存放对象实例,为所有对象实例分配内存.\r\n\r\n方法:\r\n\r\n| 使用  | 方法名 | 含义  | 返回值 |\r\n| --- | --- | --- | --- |\r\n| 长度  | length() | 字符串长度(汉字是一个一个计算的) | int  返回字符个数 |\r\n| 查找单个 | 字符串.charAt(下标) | 获取在该字符串中该下标的字符 | char 返回字符 |\r\n| 截取  | 字符串.substring(下标) | 从下标截取字符串,原字符串不改变 | string 返回一个新的字符串 |\r\n| 截取区间 | 字符串.substring(起始下标,结束下标) | 从起始下标开始到结束下标-1(左闭右开) | 返回新的字符串 |\r\n| 分割  | 字符串.spilt(分割字符) | 字符串分割,注意符号,有些需要转义 |     |\r\n| 查找子串 | 字符串.indexOf(子串) | 从字符串中查找子串(从左到右) | 返回第一次查到的下标 |\r\n| 查找子串 | 字符串.lastindexOf(子串) | 从右到左 | 返回左后一个下标 |\r\n| 比较字符串 | 字符串1.equals(字符串2) | 比较是否相等,不管地址,只与值有关 | boolean |\r\n| 比较顺序 | 字符串.compareTo(参数串) | 比较的是字典顺序 | 0相同,1不同 ,负的,正的 |\r\n| 替换  | 字符串.replace(old,new) | 将所有 old 都替换为 new 字符子串 | 返回新的字符串,不改变原字符串 |\r\n| 去掉末尾空格 | 字符串.trim() |     |     |\r\n\r\n分割\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            String s = \"aa,am,df,fa,df,\";\r\n            System.out.println(Arrays.toString(s.split(\",\")));\r\n        }\r\n    }\r\n\r\n正则 : matches:\r\n\r\n    字符串.matches(正则表达式) //返回值为boolean类型\r\n\r\n1.正则的开始为 ^\r\n\r\n2.正则的结束为 $\r\n\r\n3.正则的内容 [abc] abc中任选一个 [a-z]a-z任选一个 直接匹配@qq.com 0411-\r\n\r\n4.正则的位数{n},就是n为{n,m} n到m , {n, } n位以上\r\n\r\n5.\\d[0-9] \\w[0-9a-zA-Z]\r\n\r\n6.特殊位数 : + 1 个或多个 ? 0 或1个 * 0个或多个\r\n\r\n7.或者 |\r\n\r\n    public class Main {\r\n    \r\n        // 验证身份证号\r\n        public static boolean checkSFZ(String no){\r\n            return no.matches(\"^[1-8]\\\\d{16}[X|0-9]$\");\r\n        }\r\n    \r\n        //验证手机号\r\n        public static boolean checkSJH(String no){\r\n            return no.matches(\"^(153|138)\\\\d{8}$\");\r\n        }\r\n    \r\n        public static void main(String[] args) {\r\n            String s1 = \"34292120050814471X\";\r\n    \r\n            String s3 = \"15360669499\";\r\n            System.out.println(checkSFZ(s1));\r\n    \r\n            System.out.println(checkSJH(s3));\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n### 4.2 StringBuilder 和 StringBuffder\r\n\r\n可变字符串,在原串的基础上可以增删改\r\n\r\n总结:\r\n\r\nString是不可变字符串, 不能改变\r\n\r\nStringBuffder: 可变字符串,线程安全,效率低\r\n\r\nStringBuilder: 可变字符串,线程不安全,效率高 ,推荐使用\r\n\r\n#### 4.2.1 StringBuilder\r\n\r\n可变的字符序列,相当于字符串的缓冲区,是可以改变的\r\n\r\n    new Stringbuilder()    //创建的字符串缓冲区是16个字节\r\n    new Stringbuilder()    //创建指定容量的缓冲            \r\n    new Stringbuilder()    //创建字符串缓冲区,存入默认字符串,并且将String转为StringBuilder类型\r\n    \r\n    \r\n    public class Main {\r\n    \r\n        public static void main(String[] args) {\r\n            StringBuilder stringBuilder = new StringBuilder(\"10\");\r\n            System.out.println(stringBuilder.length());\r\n            System.out.println(stringBuilder.capacity());\r\n    \r\n        }\r\n    }\r\n\r\nstring里面的方法stringBuilder也可以使用\r\n\r\n| 方法名 |     |     |\r\n| --- | --- | --- |\r\n| length | 字符串长度,内容个数 | int |\r\n| capacity | 缓冲区大小,容量 | int |\r\n| append(字符串) | 在原串尾部追加 | StringBuilder |\r\n| insert(下标,字符串) | 在该下标前出入字符串 | StringBuilder |\r\n| deleteCharAt(下标) | 根据下标删除一个字符 |     |\r\n| delete(s,e) | 删除区间,从s已知删除到e-1 |     |\r\n| setCharAt(下标,修改字符) | 在对应下标的位置修改一个字符 |     |\r\n| reverse() | 字符串反转 | StringBuilder |\r\n\r\n    public class Main {\r\n    \r\n        public static boolean HW(String no){\r\n            StringBuilder s = new StringBuilder(no);\r\n    \r\n            return s.compareTo(s.reverse()) == 0;\r\n        }\r\n        public static void main(String[] args) {\r\n            String s =(\"123454321\");\r\n            if(HW(s)){\r\n                System.out.println(\"是回文\");\r\n            }else {\r\n                System.out.println(\"不是\");\r\n            }\r\n        }\r\n    } \r\n\r\n## 第五章 包装类\r\n\r\n### 5.1包装类\r\n\r\n八个类和八个基本数据类型对应的类,将每个离散的数据类型包装成类型\r\n\r\n| 包装类 | 基本类型 |\r\n| --- | --- |\r\n| Byte | byte |\r\n| Short | short |\r\n| Integer | int |\r\n| Long | long |\r\n| Float | float |\r\n| Double | double |\r\n| Character | char |\r\n| Bollean | bool |\r\n\r\n### 5.2 包装类和基本数据类型转换\r\n\r\n装箱: 将基本类型转换成包装类\r\n\r\n    // 手动装箱\r\n    new Intager(int){\r\n    \r\n    }\r\n    //自动装箱\r\n     int a = 10;\r\n     Intager i = a; \r\n    //不同类型之间不允许转换\r\n    \r\n    // 拆箱\r\n    Integer i =10;\r\n    int a = i; \r\n    \r\n\r\n### 5.3包装/基本类型和String转换\r\n\r\n1.基本类型转化为String\r\n\r\n    // 拼接\r\n    String a = \"a\";\r\n    System.out.plantln(a+\"b\");\r\n    System.out.plantln(a.concat(\"b\");\r\n    \r\n    // 转化为包装对象\r\n    int a =10;\r\n    Integer i = a;\r\n    System.out.println(i.toString());\r\n    \r\n    // valueOf\r\n    int a = 10;\r\n    String.valueOf(a);\r\n\r\n2.String转化为其它类型\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            String b = \"11\";\r\n            int a = Integer.parseInt(b);\r\n            double c = Double.parseDouble(String.valueOf(a));\r\n            System.out.println(a);\r\n            System.out.println(c);\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n## 第六章 Object\r\n\r\nobject是所有类的根类,所有类都直接或者间接基础该类\r\n\r\nnew Object() 供子类调用\r\n\r\n| 方法  | 含义  |\r\n| --- | --- |\r\n| finalize | 垃圾回收方法,JVM自行调用,无需手动调用 |\r\n| hashCode() | 返回对象的哈希值,根据哈希表提供 |\r\n| equals() | 比较值 |\r\n| wait() | 线程堵塞方法 |\r\n| notify() | 唤醒方法 |\r\n\r\n## 第七章 集合类\r\n\r\n### 7.1 集合的概念\r\n\r\n集合作为java中的存储介质,和数组不同\r\n\r\n1.集合中的元素类型可以不一样,(默认成Object)\r\n\r\n2.集合的大小可以改变,可以扩充,方便增删改\r\n\r\n### 7.2 集合的分类\r\n\r\n系列一:\r\n\r\nCollection接口: 存储值\r\n\r\n        List子接口: 有下标, 0 开始, 顺序存储\r\n\r\n                ArrayList实现类 : 线性存储结构,元素挨着,适合查询,不适合更新,线程不安全,效率高,不同步,速度快 (双链表+红黑树)\r\n\r\n                LinkedList实现类: 链式存储结构,元素不挨着,适合更新,不适合查找,线程不安全,效率高,不同步,速度快\r\n\r\n                Vector实现类: 线程安全,效率低,同步\r\n\r\n        Set子接口: 没有下标, 不能保证顺序,吞并重复元素(谁是后面添加重复的去掉谁)\r\n\r\n                HashSet实现类 : 哈希标存储, 自动去重\r\n\r\n                TreeSet实现类 : 红黑树存储,可以自然排序\r\n\r\n系列二:\r\n\r\nMap接口:存储的是键值对\r\n\r\n        HashMap实现类 : 线程不安全,效率高,不同步,速度快\r\n\r\n        Hashtable实现类 : 线程安全,效率低,同步\r\n\r\n        TreeMap实现类 : 自然排序,根据 HsahCode 实现\r\n\r\n### 7.3 ArrayList集合\r\n\r\n可变容量数组,随着元素的增加而扩容,线性存储结构,List实现类\r\n\r\n底层有容量判断机制,自动扩容\r\n\r\n    构造方法\r\n        new ArrayList() //空构造\r\n        new ArrayList(Collection c); //使用多态构建集合\r\n\r\n方法:\r\n\r\n| 方法  | 含义  | 返回值 |\r\n| --- | --- | --- |\r\n| add(元素) | 在尾部添加元素 | bool 是否添加成功 |\r\n| add(下标,元素) | 在下标前插入元素 | 无   |\r\n| size() | 获取集合大小 | int |\r\n| remove(下标) | 根据下标删除元素 |     |\r\n| remove(元素) | 根据元素删除 | bool |\r\n| get(下标) | 根据下标获取一个元素 | 一个元素 |\r\n| set(下标,元素) | 根据下标修改元素 | 无   |\r\n| clear() | 取出元素 |     |\r\n| indexOf(元素)/lastindexOf(元素) | 元素查找 |     |\r\n\r\n注意: 当remove进行删除时,只要传入int参数时,默认为是下标\r\n\r\n    public class Main {\r\n    \r\n        public static void main(String[] args) {\r\n            List<Integer> list = new ArrayList<>();\r\n            list.add(20);\r\n            list.add(40);\r\n            list.add(60);\r\n            list.add(80);\r\n            System.out.println(list);\r\n            System.out.println(list.size());\r\n            System.out.println(list.remove(0));      \r\n            System.out.println(list.get(2));\r\n            System.out.println(list.remove(list.set(list.size()-1,100))); \r\n    \r\n            for (Integer i : list) {\r\n                System.out.println(i);\r\n            }\r\n    \r\n            for (int i = 0; i < list.size(); i++) {\r\n                System.out.println(list.get(i));\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n### 7.4 HashSet集合\r\n\r\n内存: 哈希表\r\n\r\n    构造方法:\r\n        new HashSet();\r\n        new HashSet(Collection c);\r\n    \r\n    \r\n\r\n方法:\r\n\r\n| 方法名 | 含义  | 返回值 |\r\n| --- | --- | --- |\r\n| add() | 尾部增加,不能插入 |     |\r\n| remove(元素) | 删除对应元素 |     |\r\n| size() | 大小  |     |\r\n| iterator() | 返回该集合的迭代器 |     |\r\n| hashNext() | 是否有迭代元素 |     |\r\n| next | 取出下一个元素 |     |\r\n\r\n    public class Main {\r\n    \r\n        public static void main(String[] args) {\r\n            HashSet<Integer> set = new HashSet<>();\r\n            set.add(40);\r\n            set.add(50);\r\n            set.add(60);\r\n    \r\n            System.out.println(set.remove(30));\r\n            System.out.println(set);\r\n    \r\n            HashSet<Integer> set2 = new HashSet<>();\r\n    \r\n            int[] a = {10,20,30};\r\n            int[] b = {15,20,35};\r\n            for (int k : a) {\r\n                set2.add(k);\r\n            }\r\n            for (int j : b) {\r\n                set2.add(j);\r\n            }\r\n    \r\n            System.out.println(set2);\r\n    \r\n        }\r\n    }\r\n\r\n    public class Main {\r\n    \r\n        public static void main(String[] args) {\r\n            HashSet<Integer> set = new HashSet<>();\r\n            set.add(40);\r\n            set.add(50);\r\n            set.add(60);\r\n    \r\n            Iterator <Integer>i = set.iterator();\r\n            while (i.hasNext()){\r\n                System.out.println(i.next());\r\n            }\r\n        }\r\n    }\r\n\r\n### 7.5 TreeSet集合\r\n\r\n存储的元素回实现自然排序,(排序算法)\r\n\r\n构造方法:\r\n\r\n    new TreeSet();\r\n    new TreeSet(Collection c);\r\n    new TreeSet(Comparator c);     // 传入比较器,比较算法\r\n\r\n| 方法名 | 含义  | 返回值 |\r\n| --- | --- | --- |\r\n| add(元素) | 添加  |     |\r\n| size() | 获取集合大小 |     |\r\n|     |     |     |\r\n\r\n    public class Main {\r\n    \r\n        public static void main(String[] args) { \r\n            // 默认自然排序,升序\r\n            TreeSet<Integer> set = new TreeSet<>();\r\n            set.add(40);\r\n            set.add(50);\r\n            set.add(60);\r\n            set.add(20);\r\n            set.add(30);\r\n    \r\n            System.out.println(set);\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n\r\n    public class Main {\r\n    \r\n        public static void main(String[] args){ \r\n            // 默认根据首字母排序,升序\r\n            TreeSet<String> set = new TreeSet<>();\r\n            set.add(\"app\");\r\n            set.add(\"black\");\r\n            set.add(\"cap\");\r\n            set.add(\"door\");\r\n            set.add(\"eat\");\r\n    \r\n            System.out.println(set);\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n比较机制:\r\n\r\n    Comparator 比较器,决定如何比较\r\n\r\n    Comparable 比较标志,实现类该接口的自然排序\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n           TreeSet<Furit> furits = new TreeSet<>();\r\n            furits.add(new Furit(2,\"苹果\",3,200));\r\n            furits.add(new Furit(1,\"香蕉\",4,100));\r\n            furits.add(new Furit(3,\"鸭梨\",5,300));\r\n    \r\n            for (Furit furit : furits) {\r\n                System.out.println(furit);\r\n            }\r\n        }\r\n    } \r\n    \r\n    \r\n    public class Furit implements Comparable<Furit>{\r\n        private int fno;\r\n        private String fName;\r\n        private double price;\r\n        private int counts;\r\n    \r\n        public Furit() {\r\n    \r\n        }\r\n    \r\n        public Furit(int fno, String fName, double price, int counts) {\r\n            this.fno = fno;\r\n            this.fName = fName;\r\n            this.price = price;\r\n            this.counts = counts;\r\n        }\r\n    \r\n        @Override\r\n        public String toString() {\r\n            return \"Furit{\" +\r\n                    \"fno=\" + fno +\r\n                    \", fName=\'\" + fName + \'\\\'\' +\r\n                    \", price=\" + price +\r\n                    \", counts=\" + counts +\r\n                    \'}\';\r\n        }\r\n    \r\n        public int getCounts() {\r\n            return counts;\r\n        }\r\n    \r\n        public void setCounts(int counts) {\r\n            this.counts = counts;\r\n        }\r\n    \r\n        public double getPrice() {\r\n            return price;\r\n        }\r\n    \r\n        public void setPrice(double price) {\r\n            this.price = price;\r\n        }\r\n    \r\n        public String getfName() {\r\n            return fName;\r\n        }\r\n    \r\n        public void setfName(String fName) {\r\n            this.fName = fName;\r\n        }\r\n    \r\n        public int getFno() {\r\n            return fno;\r\n        }\r\n    \r\n        public void setFno(int fno) {\r\n            this.fno = fno;\r\n        }\r\n    \r\n        @Override\r\n        public int compareTo(Furit o) {\r\n            if (o.getFno()==this.fno){\r\n                return 0;\r\n            }\r\n            if (o.getFno()>this.fno){\r\n                return -1;\r\n            }else{\r\n                return 1;\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n比较器Comparator:\r\n\r\n    public class Main {\r\n    \r\n        public static void main(String[] args) {\r\n            // 匿名内部类实现比较\r\n           TreeSet<String> treeSet = new TreeSet<>(new Comparator<String>(){\r\n               @Override\r\n               public int compare(String o1, String o2) {\r\n                   if (o1.length() - o2.length() ==0){\r\n                       return o1.compareTo(o2);\r\n                   } else if (o1.length() - o2.length() > 0) {\r\n                       return 1;\r\n                   }else {\r\n                       return -1;\r\n                   }\r\n               }\r\n           });\r\n    \r\n            treeSet.add(\"abc\");\r\n            treeSet.add(\"abb\");\r\n            treeSet.add(\"acc\");\r\n            treeSet.add(\"bac\");\r\n            treeSet.add(\"baa\");\r\n    \r\n            for (String s : treeSet) {\r\n                System.out.println(s);\r\n            } \r\n    \r\n           // lambda实现比较\r\n           TreeSet<String> treeSet = new TreeSet<>(Comparator.comparingInt(String::length));\r\n    \r\n        }\r\n    }\r\n\r\n### 7.6 HashMap集合\r\n\r\nHashMap存储键值对 key-value\r\n\r\n构造方法:\r\n\r\n    new HashMap<K,V>();\r\n\r\n| 方法名 | 含义  |\r\n| --- | --- |\r\n| put(键,值) | 添加元素/修改元素 |\r\n| size() | 获取大小 |\r\n| get(键) | 通过键获取值 |\r\n| remove(键) | 通过键删除整个键值对 |\r\n| containsKey(键) | 判断是否存在这个键 |\r\n| KeySet() | 以Set集合的形式返回Key的集合(遍历) |\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            Map<String ,String>map = new HashMap<>();\r\n            map.put(\"username1\",\"password\");\r\n            map.put(\"username2\",\"password\");\r\n    \r\n            //如果key重复会覆盖\r\n            map.put(\"admin\",\"admin\");\r\n            map.put(\"admin\",\"123456\");\r\n    \r\n            System.out.println(map.get(\"admin\"));\r\n    \r\n            map.remove(\"username\");\r\n            System.out.println(map);\r\n    \r\n            Set<String> keys = map.keySet();\r\n    \r\n            for (String key : keys) {\r\n                System.out.println(map.get(key));\r\n            }\r\n    \r\n            //  获取迭代器\r\n            Set<String> keys2 = map.keySet();\r\n            Iterator<String> iterator = keys2.iterator();\r\n            while (iterator.hasNext()){\r\n                System.out.println(map.get(iterator.next()));\r\n            }\r\n        }\r\n    }\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            int[] a= {1,2,3,4,5,6,4,3,6,8,6,4,3};\r\n            HashMap<Integer,Integer> hashmap = new HashMap<>();\r\n            for (int j : a) {\r\n                if (hashmap.containsKey(j)) {\r\n                    hashmap.put(j, hashmap.get(j) + 1);\r\n                } else {\r\n                    hashmap.put(j, 1);\r\n                }\r\n            }\r\n            System.out.println(hashmap);\r\n        }\r\n    }\r\n\r\n### 7.7 TreeMap\r\n\r\n存储: 红黑树,自然排序. Comparator比较器, 使用键提供排序\r\n\r\n### 7.8 集合的泛型\r\n\r\n1.泛型的概念\r\n\r\n    jdk5+ 以后新增的泛型,泛指的类型,参数化的类型\r\n\r\n2.泛型的好处\r\n\r\n    1).避免了打量的类型转化\r\n\r\n    2).增加了代码的灵活性,类型可以像参数一样传递\r\n\r\n3.三种表现形式\r\n\r\n    1).泛型接口: Comparator\r\n\r\n    2).泛型类\r\n\r\n    3).泛型方法\r\n\r\n4.语法\r\n\r\n    <T> T可以是任意类型,\r\n\r\n泛型接口\r\n\r\n    public interface Myclass<T>{\r\n        public abstrsct void getT<T,T>;\r\n    }\r\n\r\n## 第八章 工具类\r\n\r\n### 8.1 Scanner 控制台接收\r\n\r\n### 8.2 Arrays 数组的帮助类\r\n\r\nasList(T..a)将数组转化为List集合\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            List<Integer> list = Arrays.asList(1,2,3,3,4,5);\r\n            HashSet<Integer> hashMap = new HashSet<>(list);\r\n            TreeSet<Integer> treeSet = new HashSet<>(list);\r\n            System.out.println(hashMap);\r\n        }\r\n    }\r\n\r\n### 8.3 Collections 集合的帮助类\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            List<Integer> list = Arrays.asList(1,2,3,3,1,2,4,3,3,1,24,34,5);\r\n            Collections.sort(list);\r\n            int i = Collections.binarySearch(list,2);\r\n            System.out.println(i);\r\n        }\r\n    }\r\n\r\n## 第九章 日期类\r\n\r\n### 9.1 Date\r\n\r\n日期类,操作日期,java.util.Date , java.sql.Date 其中util.Date是父类\r\n\r\n构造方法:\r\n\r\n    new Date();        // 创建系统的当前时间\r\n    new Date(long);    //传入一个时间戳,返回具体的时间点\r\n\r\n方法名:\r\n\r\ngetTime() 返回一个距离1970.1.1日的时间差 long\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            Date date = new Date();\r\n            System.out.println(date);\r\n    \r\n            Date date1 = new Date();\r\n            System.out.println(date1.getTime());\r\n    \r\n            java.sql.Date sqlDate = new java.sql.Date(date.getTime());\r\n            System.out.println(sqlDate);\r\n        }\r\n    }\r\n\r\n### 9.2 日期格式化\r\n\r\nSimpelDateFormat: 日期格式化\r\n\r\n    构造方法:\r\n        new SimpleDateFormat(时间格式);\r\n\r\n方法:\r\n\r\nparse()字符串转换成日期 Date\r\n\r\nformat() 日期转化成字符串 string\r\n\r\n    public class Main {\r\n        public static void main(String[] args) throws ParseException {\r\n            Date date = new Date();\r\n            SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss E\");\r\n            System.out.println(simpleDateFormat.format(date));\r\n    \r\n            SimpleDateFormat simpleDateFormat1 = new SimpleDateFormat(\"yyyy-MM-dd\");\r\n            String s = \"2022-06-08\";\r\n            System.out.println(simpleDateFormat1.parse(s));\r\n    \r\n        }\r\n    }\r\n\r\n日期比较功能:\r\n\r\n    compareTo()方法--用字符串形式比较日期\r\n    before(指定日期)    指定日期之前--用日期格式\r\n    after(指定日期)     指定日期之后--用日期格式\r\n\r\n    public class Main {\r\n        public static void main(String[] args) throws ParseException {\r\n    \r\n            //  compareTo 如果大于参数日期返回正的,小于返回负的\r\n            String s = \"2022-06-08 00:00:00\";\r\n            String e = new SimpleDateFormat(\"yyyy-MM-dd hh:mmm:ss\").format(new Date());\r\n    \r\n            System.out.println(s.compareTo(e));\r\n            System.out.println(e.compareTo(s));\r\n    \r\n            // before\r\n            String s1 = \"2023-11-13 00:00:00\";\r\n            String e1 = \"2023-11-15 00:00:00\";\r\n            SimpleDateFormat simpleDateFormat =new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\r\n            Date date1 = simpleDateFormat.parse(s1);\r\n            Date date2 = simpleDateFormat.parse(e1);\r\n            System.out.println(date1.before(date2));\r\n        }\r\n    }\r\n\r\n### 9.3 Calendar日历类\r\n\r\n日历类:是一个抽象类,不能new, 使用时需要调用方法getInstance()返回一个通用的日历对象\r\n\r\n方法:\r\n\r\n    getInstance()返回一个对象实例     Calendar\r\n\r\n    set(参数)        设置日期和时间的方法\r\n\r\n    get(参数)    获取指定域的值\r\n\r\n    public class Main {\r\n        public static void main(String[] args) throws ParseException {\r\n    \r\n            Calendar  calendar = Calendar.getInstance();\r\n            calendar.set(2011, 1,3);\r\n            System.out.println(calendar.get(Calendar.YEAR));\r\n        }\r\n    }\r\n\r\n## 第十章 精度处理类\r\n\r\n用于处理精度问题的类 , BigDecimal,精度处理类\r\n\r\n构造方法:\r\n\r\n    new BigDecimal(String opr)\r\n\r\n方法:\r\n\r\n| 方法名 | 含义  | 返回值 |\r\n| --- | --- | --- |\r\n| add() | 加   | BigDecimal |\r\n| subtrat() | 减   | BigDecimal |\r\n| multiply | 乘   | BigDecimal |\r\n| divide() | 除   | BigDecimal |\r\n\r\n    public class Main {\r\n        public static void main(String[] args) throws ParseException {\r\n            double d1 = 2.2;\r\n            double d2 =3.3;\r\n            BigDecimal bigDecimal1 = new BigDecimal(d1+\"\");\r\n            BigDecimal bigDecimal2 = new BigDecimal(d2);\r\n            System.out.println(bigDecimal1);\r\n            System.out.println(bigDecimal2);\r\n    \r\n            System.out.println(bigDecimal1.add(bigDecimal2));\r\n            System.out.println(bigDecimal1.subtract(bigDecimal2));\r\n            System.out.println(bigDecimal1.multiply(bigDecimal2));\r\n    //        System.out.println(bigDecimal1.divide(bigDecimal2));\r\n        }\r\n    }\r\n\r\n## 第十一章 java.io\r\n\r\nio: input output 输入输出 ,IOException FileNOtFoundException\r\n\r\n### 11.1 什么是文件\r\n\r\n相关记录构成的数据集都叫做文件: 文本文档,图片,压缩包,硬盘,光盘,...嗾使文件,我呢见可以持久化数据,弊端:共享性较差\r\n\r\n### 11.2 File类\r\n\r\n用于操作文件和目录(文件夹)\r\n\r\n构造方法:\r\n\r\n    new File(\"C:\\\\1.txt\") // 文件\r\n    new File(\"C:\\\\a\") //操作文件夹\r\n\r\n| 方法名 | 含义  |\r\n| --- | --- |\r\n| exists() | 文件是否存在 |\r\n| length() | 文件长度 |\r\n| lastModifiled() | 最后修改文件的时间 |\r\n| createNewFile() | 创建文件 |\r\n| delete() | 删除文件 |\r\n\r\n    public class Main {\r\n        public static void main(String[] args) throws IOException {\r\n            File file = new File(\"1.txt\");\r\n            if (file.exists()){\r\n                System.out.println(\"文件存在\");\r\n    \r\n                System.out.println(\"文件路径:    \"+file.getPath());\r\n                System.out.println(\"文件是否可以被读取: \"+file.canRead());\r\n                System.out.println(\"文件内容长度: \"+file.length());\r\n    \r\n                SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\r\n                System.out.println(\"文件创建时间: \"+simpleDateFormat.format(file.lastModified())); \r\n    //            file.delete()\r\n            }else{\r\n                file.createNewFile();\r\n            }\r\n        }\r\n    }}\r\n    \r\n        }\r\n    }\r\n\r\n操作目录的方法:\r\n\r\n| 方法名 | 含义  |\r\n| --- | --- |\r\n| mkdirs() | 无需父目录,直接创建目录文件夹 |\r\n| mkdir() | 在父目录存在时创建文件 |\r\n| listFiles() | 列举文件夹中的单下层所以文件的路径 |\r\n| isDiretory() | 判断是否是文件 |\r\n| delete() | 必须删除空目录 |\r\n\r\n### 11.3 流\r\n\r\n#### 11.3.1 什么是流\r\n\r\n一连串的数据信号,数据管道,连接的桥梁,称之为流\r\n\r\n#### 11.3.2 流的分类\r\n\r\n1.流的方向\r\n\r\n    输入流 : 读文件\r\n\r\n    输出流 : 写文件\r\n\r\n2.文本类型:\r\n\r\n    文本文件 字符型文件 .txt .java 根类 :Reader 读 Writer 写\r\n\r\n    二进制文件 字节型文件 .doc mp4 excel 根类: InputStream 读 OutputStream写\r\n\r\n3.流的通量\r\n\r\n    节点流\r\n\r\n    缓冲流\r\n\r\n#### 11.3.3 字节型读文件\r\n\r\n    InputStream > InputStream\r\n\r\n构造方法:\r\n\r\n    new FileInputSteam(String name);\r\n    new FileInputStream(File f);\r\n\r\n| 方法名 | 含义  |\r\n| --- | --- |\r\n| read() | 每次读取一个字节 |\r\n| close() | 关闭流的相关资源 |\r\n| read(byte[]) | 每次读一个数组长度 |\r\n\r\n    public class Main {\r\n        public static void main(String[] args) throws IOException {\r\n            FileInputStream fileInputStream = new FileInputStream(\"1.txt\");\r\n    \r\n            int r = fileInputStream.read();\r\n    \r\n            while (r !=-1){\r\n                System.out.println((char) (r));\r\n                r=fileInputStream.read();\r\n            }\r\n            fileInputStream.close();\r\n    \r\n            FileInputStream fileInputStream1 = new FileInputStream(\"1.txt\");\r\n            int n = fileInputStream1.available();\r\n            for (int i = 0; i < n; i++) {\r\n                System.out.println((char) fileInputStream1.read());\r\n            }\r\n            fileInputStream1.close();\r\n        }\r\n    }\r\n\r\n#### 11.3.4 字节型写文件\r\n\r\nOutputStream > FileOutputStream\r\n\r\n构造方法:\r\n\r\n    new FileOutputStream(File f, boolean appead);\r\n    new FileOutputStream(File f); \r\n\r\n| 方法名 | 含义  |\r\n| --- | --- |\r\n| write() | 每次写入一个字节 |\r\n| close() | 关闭流的相关资源 |\r\n| write(byte[]) | 每次写入一个数组长度 |\r\n\r\n    \r\n    public class Main {\r\n        public static void main(String[] args) throws IOException {\r\n            File file = new File(\"1.txt\");\r\n            if (file.isDirectory()){\r\n                file.delete();\r\n            }else {\r\n                file.createNewFile();\r\n            }\r\n    \r\n            FileOutputStream fileOutputStream = new FileOutputStream(\"1.txt\",true);\r\n    \r\n            fileOutputStream.write(\'a\');\r\n            fileOutputStream.write(\'b\');\r\n            fileOutputStream.write(\'c\');\r\n            fileOutputStream.write(\'d\');\r\n            fileOutputStream.write(\'\\n\');\r\n            fileOutputStream.write(\'e\');\r\n            fileOutputStream.write(\'f\');\r\n            fileOutputStream.write(\'g\');\r\n            fileOutputStream.write(\'h\');\r\n    \r\n            fileOutputStream.close();\r\n    \r\n            FileInputStream fileInputStream = new FileInputStream(\"1.txt\");\r\n            int n = fileInputStream.available();\r\n            for (int i = 0; i < n; i++) {\r\n                System.out.print((char) fileInputStream.read());\r\n            }\r\n            fileInputStream.close();\r\n        }\r\n    }\r\n\r\n字节型复制:\r\n\r\n    public class Main {\r\n        public static void main(String[] args) throws IOException {\r\n            File file1 = new File(\"2.txt\");\r\n            if (file1.isDirectory()){\r\n                file1.delete();\r\n            }else {\r\n                file1.createNewFile();\r\n            }\r\n    \r\n            FileInputStream fileInputStream = new FileInputStream(\"1.txt\");\r\n            byte[] b=new byte[fileInputStream.available()];\r\n    \r\n            FileOutputStream fileOutputStream = new FileOutputStream(\"2.txt\");\r\n            int i = fileInputStream.read(b,0,b.length);\r\n            while (i!=-1){\r\n                fileOutputStream.write(b,0,b.length);\r\n                i = fileInputStream.read(b,0,b.length);\r\n            }\r\n            fileOutputStream.close();\r\n            fileInputStream.close();\r\n        }\r\n    }\r\n\r\n#### 11.3.5 字符型读文件\r\n\r\nReader > InputStreamReader > FileReader\r\n\r\n    new FileReader(String name);\r\n    new FileReader(File f ,boolean append);\r\n\r\n    public class Main {\r\n        public static void main(String[] args) throws IOException {\r\n            FileReader fileReader = new FileReader(\"1.txt\");\r\n            int r = fileReader.read();\r\n            while (r!=-1){\r\n                System.out.print((char) r);\r\n                r=fileReader.read();\r\n            }\r\n            fileReader.close();\r\n        }\r\n    }\r\n\r\n#### 11.3.6 字符型写文件\r\n\r\nWriter > OutputStreamWriter > FileWriter 字符型输出流\r\n\r\n构造方法:\r\n\r\n    new FileWriter(String anme);\r\n    new FileWriter(File f, bollean append); \r\n\r\n| 方法名 | 含义  |\r\n| --- | --- |\r\n| writer() | 每次写入一个字符串 |\r\n| close() |     |\r\n| writer(int i) | 每次写入一个字符 |\r\n| apppend(字符串) | 追加内容 |\r\n\r\n#### 11.3.7 缓冲流\r\n\r\n节点流: 直接和文件打交道(字符流)\r\n\r\n缓冲流: 处理流,堆节点进行处理,不会直接操作文件,加快读写效率,方便流的操作\r\n\r\nBufferReader 缓冲读取输入流\r\n\r\nBufferWriter 缓冲写入输出流\r\n\r\n构造方法:\r\n\r\n    new BufferReader(Reader r);\r\n    new BufferWriter(Writer w);\r\n\r\n方法:\r\n\r\n| 方法名 | 含义  |\r\n| --- | --- |\r\n| readLine() | 每次读取一行 |\r\n| close() |     |\r\n| writer() | 每次写入字符串 |\r\n| newLine() | 换行  |\r\n| flush() | 刷新,关闭前要刷新一下 |\r\n\r\n    // 读取\r\n    public class Main {\r\n        public static void main(String[] args) throws IOException {\r\n            FileReader fileReader =  new FileReader(\"1.txt\");\r\n            BufferedReader bufferedReader =new BufferedReader(fileReader);\r\n            String i = bufferedReader.readLine();\r\n            while (i!=null){\r\n                System.out.println(i);\r\n                i = bufferedReader.readLine();\r\n            }\r\n        }\r\n    } \r\n    \r\n    // 写入\r\n    public class Main {\r\n        public static void main(String[] args) throws IOException {\r\n            FileWriter fileWriter =  new FileWriter(\"1.txt\");\r\n            BufferedWriter bufferedReader =new BufferedWriter(fileWriter);\r\n            bufferedReader.newLine();\r\n            bufferedReader.write(\"ijkl\");\r\n            bufferedReader.close();     //关闭自带刷新操作,只有刷新之后缓冲流里面的东西才真正输出到文件里\r\n        }\r\n    }\r\n\r\n#### 11.3.8 字节流和字符流适配器\r\n\r\n字节流向字符流转化: InputStreamReader,字节流向字符流的桥梁\r\n\r\n构造方法:\r\n\r\n    new InputStreamReader(字节流)    //构键后就变为字符流\r\n\r\n    public class Main {\r\n        public static void main(String[] args) throws IOException {\r\n            // 字节流\r\n            InputStream inputStream = System.in;\r\n            // 字符流\r\n            InputStreamReader inputStreamReader = new InputStreamReader(inputStream);\r\n            // 缓冲流\r\n            BufferedReader bufferedReader = new BufferedReader(inputStreamReader);\r\n    \r\n            String  s = bufferedReader.readLine();\r\n            System.out.println(s);\r\n        }\r\n    }\r\n\r\n#### 11.3.9 PrintWriter\r\n\r\n文本输出打印流:\r\n\r\n特点:    \r\n\r\n    1.自动创建文件\r\n\r\n    2.自带缓冲\r\n\r\n    3.自带换行\r\n\r\n    4.自带刷新\r\n\r\n构造方法:\r\n\r\n    new PrintWriter(OutputStream os,boolean autoFlush);     //自带刷新\r\n    new PrintWriter(OutputStream os);\r\n\r\n| 方法名 | 含义  |\r\n| --- | --- |\r\n| println() | 输出并且换行 |\r\n| print() | 输出不换行 |\r\n| close() | 关闭  |\r\n| format() | 格式化 |\r\n\r\n    public class Main {\r\n        public static void main(String[] args) throws IOException {\r\n            PrintWriter printWriter = new PrintWriter(\"1.txt\");\r\n            printWriter.println(\"abc\");\r\n            printWriter.print(\"def\");\r\n            printWriter.format(\"%04d\",10);\r\n            printWriter.close();\r\n        }\r\n    }\r\n\r\n    public class Main {\r\n        public static void main(String[] args) throws IOException {\r\n            PrintWriter printWriter = new PrintWriter(\"1.txt\");\r\n            System.out.println(\"请输入成绩: \");\r\n            Scanner scanner = new Scanner(System.in);\r\n            String s = scanner.next();\r\n            while (!s.equals(\"end\")){\r\n                printWriter.println(s);\r\n                System.out.println(\"请继续输入成绩: \");\r\n                s = scanner.next();\r\n            }\r\n            printWriter.close();\r\n            scanner.close();\r\n        }\r\n    }\r\n\r\n## 11.4 对象的序列化\r\n\r\n对象序列化和反序列化: 对象的持久化, 将java对象持久存入到文件中,当需要时再从文件中读取出来\r\n\r\n对象序列化: 将文件写入到文件中\r\n\r\n反序列化: 将对象从文件中读取出来\r\n\r\nInputStream > ObjectInputStream\r\n\r\nOutputStram > ObjectOutputSream\r\n\r\n注意: 类是通过接口 Serializable 以启用序列化功能,未实现此接口的类将无法使其任何状态序列化或反序列化,可序列化 的类所有的子类和本身都可以序列化\r\n\r\n序列化接口中没有方法或字段,仅用于表示可序列化的语义\r\n\r\n构造方法:\r\n\r\n    new ObjectInputStream(InputSream is);    //反序列化对象\r\n    new ObjectOutputSream(OutputStram os);    //序列化对象\r\n\r\n方法:\r\n\r\n    writeObject(对象)    //写入对象\r\n    readObject()        //读取对象,返回对象,需要强转成需要的类型\r\n\r\n    public class Main {\r\n        public static void main(String[] args) throws IOException, ClassNotFoundException {\r\n            Integer i = 10;\r\n            String s = \"yy\";\r\n            Student student = new Student(1,\"jy\");\r\n    \r\n            FileOutputStream fileOutputStream = new FileOutputStream(\"1.txt\");\r\n            ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);\r\n    \r\n            objectOutputStream.writeObject(student);\r\n            objectOutputStream.writeObject(i);\r\n            objectOutputStream.writeObject(s);\r\n    \r\n            FileInputStream fileInputStream = new FileInputStream(\"1.txt\");\r\n            ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);\r\n    \r\n            Student student1 = (Student) objectInputStream.readObject();\r\n            Integer i1 = (Integer) objectInputStream.readObject();\r\n            String s1 = (String) objectInputStream.readObject();\r\n    \r\n            System.out.println(student1.toString());\r\n            System.out.println(i1);\r\n            System.out.println(s1);\r\n    \r\n            fileInputStream.close();\r\n            fileOutputStream.close();\r\n            objectOutputStream.close();\r\n            objectInputStream.close();\r\n        }\r\n    } \r\n    \r\n     package org.example;\r\n    \r\n    import java.io.Serializable;\r\n    \r\n    public class Student implements Serializable {\r\n        private int sno;\r\n        private String name;\r\n    \r\n        public int getSno() {\r\n            return sno;\r\n        }\r\n    \r\n        public void setSno(int sno) {\r\n            this.sno = sno;\r\n        }\r\n    \r\n        public String getName() {\r\n            return name;\r\n        }\r\n    \r\n        public void setName(String name) {\r\n            this.name = name;\r\n        }\r\n    \r\n        public Student(int sno, String name) {\r\n            this.sno = sno;\r\n            this.name = name;\r\n        }\r\n    \r\n        public Student() {\r\n        }\r\n    \r\n        @Override\r\n        public String toString() {\r\n            return \"Student{\" +\r\n                    \"sno=\" + sno +\r\n                    \", name=\'\" + name + \'\\\'\' +\r\n                    \'}\';\r\n        }\r\n    }\r\n    \r\n\r\n## 11.5 Properties\r\n\r\n配置文件: key-value\r\n\r\n数据库连接,国际化文件,配置端口....\r\n\r\n## 第十二章 多线程\r\n\r\n### 12.1 线程的基本概念\r\n\r\n应用程序: 静态的程序\r\n\r\n进程: 当应用程序启动,开辟进程,开辟独立运行空间\r\n\r\n线程: 程序的控制流\r\n\r\n一个应用程序至少包含一个进程,一个进程包含多个线程\r\n\r\n进程与线程的区别:\r\n\r\n    1.进程是程序运行的基本单元,必须开辟独立内存,分配资源\r\n    2.线程是进程中的最小执行单元,线程不需要开辟独立的空间\r\n\r\n### 12.2 多线程的好处\r\n\r\n提高执行的效率\r\n\r\n### 12.3 多线程的创建\r\n\r\n方式一: 继承类: java.lang.Treed\r\n\r\n构造方法:\r\n\r\n    new Treed();\r\n    new Treed(String name);    //传入线程名\r\n    new Treed(Runnable r);    //构建线程,多态\r\n\r\n属性:\r\n\r\n    MIN_PRIORITY = 1\r\n    NORM_PRIORITY = 5    //默认\r\n    MAX_PRIORITY = 10\r\n\r\n注意: 优先级会影响线程的执行顺序,但并不是绝对的\r\n\r\n    public class MyTreed extends Thread{\r\n        @Override\r\n        public void run() {\r\n            System.out.println(\"myTreed\");\r\n        }\r\n    } \r\n    \r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            MyTreed myTreed =new MyTreed();\r\n            myTreed.setPriority(1);     //设值线程优先级\r\n            myTreed.start();\r\n            System.out.println(\"线程名字: \" +myTreed.getName());\r\n            System.out.println(\"主类\");\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n方法:\r\n\r\n| 方法名 | 含义  |\r\n| --- | --- |\r\n| run() | 线程体执行内容,所有的子类覆盖该方法,run方法不需要手动调用,启动后cpu自动调用 |\r\n| start() | 线程的启动,自定的线程都需要调用该方法去启动,线程启动后会进入就绪状态,每个线程值启动一次 |\r\n| getName() | 获取线程名 |\r\n| setName(String name) | 设置线程名 |\r\n| currentThread() | 返回当前线程所有信息 |\r\n| setPriority() | 设置优先级 |\r\n| sleep(毫秒) | 线程的休眠毫秒 |\r\n\r\n线程阻塞问题:\r\n\r\nsleep() : 线程自己休眠,休眠期间让出cpu给任何优先级线程,休眠结束后进入就绪状态等待cpu调用\r\n\r\njoin() : 线程加入之后,堵塞状态,先执行该线程,start()启动再join()\r\n\r\nyiled(): 线程暂停,让出cpu给线程更高的线程,没有比他高的化,继续抢占cpu\r\n\r\nwait(): Object中方法,线程等待,需要唤醒\r\n\r\n方式2 ：实现接口：java.lang.Runnable\r\n\r\n在企业开发中，第二中方式常用，实现的同时，可以有其他的父类\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            Ticket ticket = new Ticket();\r\n            Thread thread = new Thread(ticket);\r\n            thread.setName(\"窗口1\");\r\n            thread.start();\r\n    \r\n            Thread thread2 = new Thread(ticket);\r\n            thread2.setName(\"窗口2\");\r\n            thread2.start();\r\n        }\r\n    } \r\n    \r\n     public class Ticket implements Runnable{\r\n        private int ticket = 10;\r\n    \r\n        @Override\r\n        public void run() {\r\n            while (true){\r\n                if(ticket<=0){\r\n                    System.out.println(\"票卖光了!\");\r\n                    return;\r\n                }\r\n                ticket--;\r\n                System.out.println(Thread.currentThread().getName()+\"成功的买出了票,剩余票: \"+ ticket);\r\n             }\r\n        }\r\n    }\r\n    \r\n    窗口1成功的买出了票,剩余票: 9\r\n    窗口2成功的买出了票,剩余票: 8\r\n    窗口1成功的买出了票,剩余票: 7\r\n    窗口2成功的买出了票,剩余票: 6\r\n    窗口1成功的买出了票,剩余票: 5\r\n    窗口2成功的买出了票,剩余票: 4\r\n    窗口1成功的买出了票,剩余票: 3\r\n    窗口2成功的买出了票,剩余票: 2\r\n    窗口1成功的买出了票,剩余票: 1\r\n    窗口2成功的买出了票,剩余票: 0\r\n    票卖光了!\r\n    票卖光了!\r\n\r\n用匿名类的方法实现多线程\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            Thread thread = new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n    \r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\nlambda表达式实现多线程\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            Thread thread = (new Thread(()->{\r\n    \r\n            }));\r\n        }\r\n    }\r\n\r\n### 12.4 线程的状态\r\n\r\n线程开始状态,线程的就绪状态,线程的执行状态,线程的堵塞状态,线程的结束状态\r\n\r\n### 12.5 线程的不同步\r\n\r\n线程同步: 当两个线程发问共享资源时,当A线程进行访问共享资源时,B线程不能操作共享数据,线程安全的,但是效率低\r\n\r\nAPI:\r\n\r\n    Vector StringBuffer HashTable\r\n\r\n线程不同步,: 多个线程并发使用,避免使用共享数据\r\n\r\nAPI:\r\n\r\n    ArrayList StringBuffer HashMap\r\n\r\nJava中线程锁的几种形式:\r\n\r\n1.sysnchronized锁\r\n\r\n    1).同步方法,给方法加锁\r\n\r\n       public synchronized void produce(){\r\n    \r\n        }\r\n\r\n    2).同步块\r\n\r\n       synchronized(共享资源){\r\n    \r\n        }\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            BankCard bankCard = new BankCard(1000);\r\n            Thread thread = (new Thread(()->{\r\n                synchronized (bankCard){\r\n                    for (int i = 0; i < 5; i++) {\r\n                        bankCard.setBalance(bankCard.getBalance()+1000);\r\n                        System.out.println(\"Thread名字:\"+Thread.currentThread().getName()+\"存入1000元\");\r\n                        System.out.println(\"卡内余额: \" + bankCard.getBalance());\r\n                        try {\r\n                            Thread.sleep(1000);\r\n                        } catch (InterruptedException e) {\r\n                            throw new RuntimeException(e);\r\n                        }\r\n                    }\r\n                }\r\n            },\"AA\"));\r\n    \r\n            Thread thread1 = (new Thread(()->{\r\n                synchronized (bankCard){\r\n                    for (int i = 0; i < 5; i++) {\r\n                        bankCard.setBalance(bankCard.getBalance()-1000);\r\n                        System.out.println(\"Thread名字:\"+Thread.currentThread().getName()+\"取出1000元\");\r\n                        System.out.println(\"卡内余额: \" + bankCard.getBalance());\r\n                        try {\r\n                            Thread.sleep(1000);\r\n                        } catch (InterruptedException e) {\r\n                            throw new RuntimeException(e);\r\n                        }\r\n                    }\r\n                }\r\n            },\"BB\"));\r\n            thread.start();\r\n            thread1.start();\r\n        }\r\n    } \r\n    \r\n     public class BankCard {\r\n        private double balance;\r\n    \r\n        public BankCard(double balance) {\r\n            this.balance = balance;\r\n        }\r\n    \r\n        public BankCard() {\r\n        }\r\n    \r\n        public double getBalance() {\r\n            return balance;\r\n        }\r\n    \r\n        public void setBalance(double balance) {\r\n            this.balance = balance;\r\n        }\r\n    \r\n    }\r\n    \r\n\r\n2.Lock锁\r\n\r\njdk5+ 语法明显,更加灵活,功能强大\r\n\r\n    lock();     //加锁\r\n    unlock();    //解锁\r\n\r\n### 12.6 死锁\r\n\r\nA线程拿到共享资源1,不释放,B线程拿到共享资源2,不释放,A和B两个线程,都要拿到共享资源才能继续执行,形成死锁\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            Thread thread1 = new Thread(new Boy());\r\n            Thread thread2 = new Thread(new Girl());\r\n    \r\n            thread1.start();\r\n            thread2.start();\r\n        }\r\n    } \r\n    \r\n    \r\n    public class MyLock {\r\n        public static Object object1 = new Object();\r\n        public static Object object2 = new Object();\r\n    } \r\n    \r\n     public class Boy implements Runnable{\r\n        @Override\r\n        public void run() {\r\n            synchronized (MyLock.object1){\r\n                System.out.println(\"男有A\");\r\n                synchronized (MyLock.object2){\r\n                    System.out.println(\"男有B\");\r\n                    System.out.println(\"哈哈哈\");\r\n                }\r\n            }\r\n        }\r\n    } \r\n    \r\n     public class Girl implements Runnable{\r\n        @Override\r\n        public void run() {\r\n            synchronized (MyLock.object2){\r\n                System.out.println(\"女有B\");\r\n                synchronized (MyLock.object1){\r\n                    System.out.println(\"女有A\");\r\n                    System.out.println(\"嘻嘻嘻\");\r\n                }\r\n            }\r\n        }\r\n    } \r\n    \r\n    \r\n    \r\n    /*\r\n    结果:\r\n    男有A\r\n    女有B\r\n    ..之后就陷入死锁状态,跑不下去\r\n    */\r\n\r\n### 12.7 线程通讯\r\n\r\n#### 12.7.1 什么是线程通讯\r\n\r\n多线程之间相互发送信号\r\n\r\n#### 12.7.2 线程通讯方法\r\n\r\njava.lang.Object\r\n\r\n    wait();        //线程等待\r\n    notify();    //唤醒单个线程\r\n    notifAll();    //唤醒所有线程\r\n\r\n#### 12.7.3 生产者消费者模式\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            Clerk clerk = new Clerk();\r\n            Thread thread1 = new Thread(new Producer(clerk));\r\n            Thread thread2 = new Thread(new Consumer(clerk));\r\n    \r\n            thread1.start();\r\n            thread2.start();\r\n        }\r\n    } \r\n    \r\n    public class Clerk {\r\n        private int product;\r\n    \r\n        // 产品生产和入库\r\n        public synchronized void produce(){\r\n            if (product>=20){\r\n                try {\r\n                    wait();\r\n                } catch (InterruptedException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }else {\r\n                product++;\r\n                System.out.println(Thread.currentThread().getName()+\"生产产品,产品剩余:\"+product);\r\n                notify();\r\n            }\r\n        }\r\n    \r\n    \r\n        // 产品消耗和出库\r\n        public synchronized void consume(){\r\n            if (product<=0){\r\n                try {\r\n                    wait();\r\n                } catch (InterruptedException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }else {\r\n                product--;\r\n                System.out.println(Thread.currentThread().getName()+\"生产消耗,产品剩余:\"+product);\r\n                notify();\r\n            }\r\n        }\r\n    } \r\n    \r\n    //生产者\r\n    public class Producer implements  Runnable{\r\n        public Clerk clerk;\r\n    \r\n        public Producer(Clerk clerk) {\r\n            this.clerk = clerk;\r\n        }\r\n    \r\n        @Override\r\n        public void run() {\r\n            while (true){\r\n                try {\r\n                    Thread.sleep(1000);\r\n                } catch (InterruptedException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n                clerk.produce();\r\n            }\r\n        }\r\n    } \r\n    \r\n    // 消费者\r\n    public class Consumer implements Runnable{\r\n        public Clerk clerk;\r\n    \r\n        public Consumer(Clerk clerk) {\r\n            this.clerk = clerk;\r\n        }\r\n    \r\n        @Override\r\n        public void run() {\r\n            while (true){\r\n                try {\r\n                    Thread.sleep(1000);\r\n                } catch (InterruptedException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n                clerk.consume();\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n### 12.8 线程池\r\n\r\n#### 12.8.1 线程池的意义\r\n\r\n每个任务都需要开辟新的线程,为了避免每次创建的消耗,提高线程的使用效率,线程池\r\n\r\n有点: 先初始化n个线程,任务可以由线程池调度分配\r\n\r\n#### 12.8.2 线程池使用的API\r\n\r\n顶层接口 java.util.connect.Executor\r\n\r\n实现类: ExecutorService(线程池的服务管理:线程接收任务 submit 关闭线程池 shutdown())\r\n\r\n帮助类: Executor(线程初始化)\r\n\r\n四种形式的线程池:\r\n\r\n1.单一模式: newSingleThreadExcutor\r\n\r\n2.固定可重用: newFixedThreadPool(int 线程个数)\r\n\r\n3.缓存: newCachedThreadPool\r\n\r\n4.定时的: newScheduleThreadPool\r\n\r\nExecutorService方法:\r\n\r\n| 方法名 | 含义  | 返回值 |\r\n| --- | --- | --- |\r\n| shutdown() | 关闭线程池不接受任务 | void |\r\n| submit(Callable c) | 提交任务 | Future |\r\n| submit(Runnable r) | 提交任务 | Future |\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            ExecutorService service = Executors.newFixedThreadPool(3);\r\n    \r\n            service.submit(()->{\r\n                System.out.println(Thread.currentThread().getName()+\":\"+1);\r\n            });\r\n    \r\n            service.submit(()->{\r\n                System.out.println(Thread.currentThread().getName()+\":\"+2);\r\n            });\r\n    \r\n            service.submit(()->{\r\n                System.out.println(Thread.currentThread().getName()+\":\"+3);\r\n            });\r\n    \r\n            service.submit(()->{\r\n                System.out.println(Thread.currentThread().getName()+\":\"+4);\r\n            });\r\n    \r\n            service.shutdown();\r\n        }\r\n    }\r\n    \r\n    /* 结果:\r\n    pool-1-thread-3:3\r\n    pool-1-thread-1:1\r\n    pool-1-thread-2:2\r\n    pool-1-thread-3:4\r\n    pool-1-thread-3:4       //线程等待输出\r\n    */\r\n    \r\n\r\nCallable类型\r\n\r\nCallable jdk5+新增的线程接口,用于设计由有返回值的线程体\r\n\r\nRunnable和Callable区别:\r\n\r\n1.Runnable 执行线程的方法时run , Callable: call\r\n\r\n2.Runnable没有返回值, Callable有Callable\r\n\r\n3.run()没有异常抛出,call有异常抛出\r\n\r\nFuture: 未来线程池中线程的计算结果\r\n\r\nget()        // 获取结果\r\n\r\n    public class Main {\r\n        public static void main(String[] args) {\r\n            ExecutorService service = Executors.newFixedThreadPool(3);\r\n    \r\n    //        Callable<Integer> callable = new Callable<Integer>() {\r\n    //            @Override\r\n    //            public Integer call() throws Exception {\r\n    //                int sum = 0;\r\n    //                for (int i = 0; i < 100; i++) {\r\n    //                    sum += 1;\r\n    //                }\r\n    //                return sum;\r\n    //            }\r\n    //        };\r\n    //        Future<Integer> future = service.submit(callable);\r\n    //\r\n    \r\n    \r\n            Future<Integer> future  = service.submit(()->{\r\n               int sum = 0;\r\n                for (int i = 0; i < 100; i++) {\r\n                    sum += 1;\r\n                }\r\n                return sum;\r\n            });\r\n    \r\n            try {\r\n                System.out.println(future.get());\r\n            } catch (InterruptedException | ExecutionException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n    \r\n            service.shutdown();\r\n        }\r\n    }','java 的常用api介绍','2024-07-06',54,_binary '',_binary '',_binary '',_binary '','0f0ede94-1aab-45e8-9123-4430a368112e.jpg',1),(16,'JAVA JDBC','## 第一章 JDBC概述\r\n\r\n### 1.1 什么是JDBC\r\n\r\n> JDBC: java DB connectivity\r\n> \r\n> SUN公司提供的能够使JAVA连接数据一套统一的API。Mysql oralce sqlserver\r\n> \r\n> java.sql.*\r\n\r\n### 1.2 JDBC作用\r\n\r\n> 使java可以执行数据库中的命令，换言之把sql语句放到java中执行\r\n\r\n### 1.3 JDBC连接底层原理\r\n\r\n> java程序->JDBC驱动->SQL命令 ->数据库\r\n\r\n### 1.4JDBC中的API\r\n\r\n| 接口/类 | 作用  |\r\n| --- | --- |\r\n| DriverManage类 | 驱动管理类 |\r\n| Driver接口 | 驱动接口 |\r\n| Connection接口 | 数据库连接 |\r\n| Statement接口 | 执行命令的接口 |\r\n| ResultSet接口 | 结果集的接口 |\r\n\r\n## 第二章 JDBC基本步骤\r\n\r\n6个步骤:\r\n\r\n1.加载驱动包\r\n\r\n2.建立与数据库的连接\r\n\r\n3.发送SQL语句\r\n\r\n4.接收数据库返回的结果 executUpdate() excut\r\n\r\n5.解析结果的内容ResultSet\r\n\r\n6.关闭连接close()\r\n\r\n### 2.1 加载驱动包\r\n\r\n    package com.example.jdbc;\r\n    \r\n    public class JDBC {\r\n        // 1.加载驱动类\r\n        static {\r\n            // 通过反射获取驱动类\r\n            try {\r\n                Class.forName(\"com.mysql.cj.jdbc.Driver\");\r\n            } catch (ClassNotFoundException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n### 2.2 创建和数据库的连接\r\n\r\n    1、准备连接数据：url 连接路径 账户名 username 密码 pass 库名\r\n        2、连接\r\n\r\n    package com.example.jdbc;\r\n    \r\n    import com.example.jdbc.pojo.Admin;\r\n    \r\n    import java.sql.*;\r\n    import java.util.ArrayList;\r\n    \r\n    public class JDBC {\r\n        private static final String url = \"jdbc:mysql://localhost:3306/blog?characterEncoding=utf-8&allowMultiQueries=true&serverTimezone=UTC\";\r\n        private static final String user = \"root\";\r\n        private static final String password = \"123456\";\r\n    \r\n        // 1.加载驱动类\r\n        static {\r\n            // 通过反射获取驱动类\r\n            try {\r\n                Class.forName(\"com.mysql.cj.jdbc.Driver\");\r\n                System.out.println(\"数据库连接成功\");\r\n            } catch (ClassNotFoundException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n    \r\n        // 2.获取链接\r\n        public static Connection getConnection() {\r\n            Connection conn;\r\n            try {\r\n                //创建连接对象\r\n                conn = DriverManager.getConnection(url, user, password);\r\n            } catch (SQLException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n            return conn;\r\n        }\r\n    \r\n        // 增\r\n        public static void addAdmin() {\r\n            String sql  = \"insert into admin (id, num, name, passwd) values (2,\'wsscg\',\'admin\',\'admin\');\";\r\n            // 获取连接\r\n            Connection conn = getConnection();\r\n    \r\n            Statement statement = null;\r\n            try {\r\n            // 执行命令接口\r\n            statement = conn.createStatement();\r\n            // 执行命令\r\n            boolean n = statement.execute(sql);\r\n            if (n) {\r\n                System.out.println(\"新增admin成功\");\r\n            }else {\r\n                System.out.println(\"新增admin失败\");\r\n            }\r\n            } catch (SQLException e) {\r\n                throw new RuntimeException(e);\r\n            }finally {\r\n                try {\r\n                    if (statement != null) {\r\n                        statement.close();\r\n                    }\r\n                    if (conn != null) {\r\n                        conn.close();\r\n                    }\r\n                } catch (SQLException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n        }\r\n    \r\n        // 查\r\n        public static ArrayList<Admin> getAdminList() {\r\n            ArrayList<Admin> list = new ArrayList<>();\r\n            String sql  = \"select * from admin\";\r\n            Connection conn = getConnection();\r\n            Statement statement = null;\r\n            try {\r\n                statement = conn.createStatement();\r\n                ResultSet rs = statement.executeQuery(sql);\r\n                // 解析\r\n                while (rs.next()) {\r\n                    Admin admin = new Admin(rs.getInt(1),rs.getString(2),rs.getString(3), rs.getString(4), rs.getString(5), rs.getString(6), rs.getString(7), rs.getString(8), rs.getString(9), rs.getString(10), rs.getString(11) );\r\n                    list.add(admin);\r\n                }\r\n                statement.close();\r\n                return list;\r\n            } catch (SQLException e) {\r\n                throw new RuntimeException(e);\r\n            }finally {\r\n                try {\r\n                    if (statement != null) {\r\n                        statement.close();\r\n                    }\r\n                    if (conn != null) {\r\n                        conn.close();\r\n                    }\r\n                } catch (SQLException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n        }\r\n    \r\n        public static void main(String[] args) {\r\n    //        addAdmin();\r\n            ArrayList<Admin> adminList =  getAdminList();\r\n            for (Admin admin : adminList) {\r\n                System.out.println(admin);\r\n            }\r\n        }\r\n    } \r\n    \r\n    public class Admin implements Serializable {\r\n        private int id;\r\n        private String num;\r\n        private String name;\r\n        private String passwd;\r\n        private String avator;\r\n        private String phone;\r\n        private String email;\r\n        private String role_id;\r\n        private String updated;\r\n        private String created;\r\n        private String salt;\r\n    \r\n        public Admin(int id, String num, String name, String passwd, String avator, String phone, String email, String role_id, String updated, String created, String salt) {\r\n            this.id = id;\r\n            this.num = num;\r\n            this.name = name;\r\n            this.passwd = passwd;\r\n            this.avator = avator;\r\n            this.phone = phone;\r\n            this.email = email;\r\n            this.role_id = role_id;\r\n            this.updated = updated;\r\n            this.created = created;\r\n            this.salt = salt;\r\n        }\r\n    \r\n        public Admin() {}\r\n    }\r\n    \r\n    \r\n\r\n## 第三章 JDBC实现分层处理\r\n\r\n    com.qf.JDBC        根包\r\n        common         公共包\r\n        pojo(entiy)    实体类包\r\n        test           测试包\r\n        dao            数据访问对象\r\n        service        业务层\r\n\r\n第四章 JDBC预编译SQL\r\n\r\n#### 4.1 PreparedStament\r\n\r\n| 接口/类 | 含义  |\r\n| --- | --- |\r\n| Statement | 执行命令接口(java和sql要一起写，才能传入参数) |\r\n| PreparedStament | 执行命令的接口，是Statement的子接口，拓展新功能 |\r\n\r\n#### 4.2 PreparedStament预编译SQL\r\n\r\n> 1、SQL语句可以提前编译，防止在SQL中添加java代码（避免繁琐的拼接）\r\n> \r\n> 2、提高了sql执行效率\r\n\r\n#### 4.3 如何实现\r\n\r\n    1、将SQL中传入的java参数全部改为？代替\r\n           String sql = \"insert into dept values(?,?,?)\";\r\n    2、将Statement换成 PreparedStament\r\n    3、赋值\r\n        setXX(？位置，值)  setInt(1,值)\r\n    4、执行\r\n        executeUpdate 不用传参\r\n    \r\n     public void addEmp(Emp emp) {\r\n            String sql = \"insert into emp(empno,ename,sal,hiredate) values(?,?,?,?)\";\r\n    //        获得连接\r\n            Connection conn = DBConn.getConn();\r\n    //        执行命令接口\r\n            PreparedStatement st = null;\r\n            try {\r\n                st = conn.prepareStatement(sql);\r\n    //            对？号进行赋值\r\n                st.setInt(1,emp.getEmpno());\r\n                st.setString(2,emp.getEname());\r\n                st.setDouble(3,emp.getSal());\r\n                st.setDate(4,emp.getHiredate());\r\n    \r\n    //          执行语句\r\n                int r = st.executeUpdate();\r\n                if (r >= 1) {\r\n                    System.out.println(\"新增成功\");\r\n                } else {\r\n                    System.out.println(\"新增失败\");\r\n                }\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            } finally {\r\n                try {\r\n                    st.close();\r\n                    conn.close();\r\n                } catch (SQLException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    \r\n        public static void main(String[] args) {\r\n            java.util.Date date = new java.util.Date();\r\n    \r\n    //        创建\r\n            EmpDao empDao = new EmpDaoImpl();\r\n            empDao.addEmp(new Emp(1,\"张三\",1000,new Date(date.getTime())));\r\n    \r\n    \r\n        }','java 通过jdbc连接mysql数据库','2024-07-06',5,_binary '',_binary '',_binary '',_binary '','3b1dc0e2-49c8-431a-8202-815e50fc8cd5.jpg',1),(17,'JAVA WEB','## **java Web**\r\n\r\n**Tomcat (java主流的web应用服务器)**\r\n\r\n### **servlet**\r\n\r\n**[Server Applet]**\r\n\r\n**servlet是Java Web的开发基石,与平台无关的服务器组件,它是运行在Servlet容器/Web应用服务器/Tomcat,负责与客户端进行通信.**\r\n\r\n**主要功能:**\r\n\r\n**1.创建并返回基于客户请求的动态Html页面**\r\n\r\n**2.与数据路之间进行通信**\r\n\r\n**Servlet本身是一组接口,(java.servlet , java.lang , java.uitl.javax.sql),自定义一个类,并且实现Servlet接口,这个类就具备了接收客户端请求以及做出相应的功能.**\r\n\r\n**maven配置**\r\n\r\n    <dependency>\r\n        <groupId>javax.servlet</groupId>\r\n        <artifactId>javax.servlet-api</artifactId>\r\n        <version>3.1.0</version>\r\n        <scope>provided</scope>\r\n    </dependency>\r\n    <dependency>\r\n        <groupId>javax.servlet.jsp</groupId>\r\n        <artifactId>javax.servlet.jsp-api</artifactId>\r\n        <version>2.3.3</version>\r\n        <scope>provided</scope>\r\n    </dependency>\r\n    <dependency>\r\n        <groupId>mysql</groupId>\r\n        <artifactId>mysql-connector-java</artifactId>\r\n        <version>8.0.31</version>\r\n    </dependency>\r\n\r\n**web.xml配置**\r\n\r\n    <servlet>\r\n        <servlet-name>hello</servlet-name>\r\n        <servlet-class>servlet.HelloServlet</servlet-class>\r\n      </servlet>\r\n      <servlet-mapping>\r\n        <servlet-name>hello</servlet-name>\r\n        <url-pattern>/hello</url-pattern>\r\n      </servlet-mapping>','java网页基础','2024-07-06',37,_binary '',_binary '',_binary '',_binary '','4d2657f7-6081-40ea-a6f7-a7ad37ef9a6c.jpg',1),(18,'TwoDots-Blog  的接口文档','    title: TwoDots-Blog\r\n    language_tabs:\r\n      - shell: Shell  - http: HTTP  - javascript: JavaScript  - ruby: Ruby  - python: Python  - php: PHP  - java: Java  - go: Go\r\n    toc_footers: []\r\n    includes: []\r\n    search: true\r\n    code_clipboard: true\r\n    highlight_theme: darkula\r\n    headingLevel: 2\r\n    generator: \"@tarslib/widdershins v4.0.23\"\r\n    \r\n\r\n# TwoDots-Blog\r\n\r\nBase URLs:\r\n\r\n# Authentication\r\n\r\n# 相册管理接口\r\n\r\n<a id=\"opIdgetAlbumsUsingGET_1\"></a>\r\n\r\n## GET 查询所有相册\r\n\r\nGET /albums\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdpostAlbumsUsingPOST\"></a>\r\n\r\n## POST 创建相册\r\n\r\nPOST /albums/admin\r\n\r\n> Body 请求参数\r\n\r\n    cover: string\r\n    \r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| token | header | string | 否   | 令牌  |\r\n| body | body | object | 否   | none |\r\n| » cover | body | string(binary) | 是   | cover |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIddeletePhotosUsingDELETE\"></a>\r\n\r\n## DELETE 删除照片\r\n\r\nDELETE /albums/admin/photoIdList\r\n\r\n> Body 请求参数\r\n\r\n    [\r\n      0\r\n    ]\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| token | header | string | 否   | 令牌  |\r\n| body | body | array[integer] | 否   | none |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdputPhotosUsingPUT\"></a>\r\n\r\n## PUT 修改照片\r\n\r\nPUT /albums/admin/photos\r\n\r\n> Body 请求参数\r\n\r\n    {\r\n      \"albums_tag\": 1,\r\n      \"photo_filming_time\": \"2023-07-15\",\r\n      \"photo_id\": 1,\r\n      \"photo_introduction\": \"A wonderful summer vacation in Hawaii.\",\r\n      \"photo_name\": \"Summer Vacation\",\r\n      \"photo_save_name\": \"summer_vacation.jpg\"\r\n    }\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| token | header | string | 否   | 令牌  |\r\n| body | body | any | 否   | none |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdpostPhotosUsingPOST\"></a>\r\n\r\n## POST 新增照片\r\n\r\nPOST /albums/admin/photos/{id}\r\n\r\n> Body 请求参数\r\n\r\n    photoList:\r\n      - null\r\n    \r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| id  | path | integer(int32) | 是   | id  |\r\n| token | header | string | 否   | 令牌  |\r\n| body | body | object | 否   | none |\r\n| » photoList | body | [file] | 是   | photoList |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdputAlbumsUsingPUT\"></a>\r\n\r\n## PUT 修改相册\r\n\r\nPUT /albums/admin/{id}\r\n\r\n> Body 请求参数\r\n\r\n    cover: string\r\n    \r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| id  | path | integer(int32) | 是   | id  |\r\n| token | header | string | 否   | 令牌  |\r\n| body | body | object | 否   | none |\r\n| » cover | body | string(binary) | 否   | cover |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIddeleteAlbumsUsingDELETE\"></a>\r\n\r\n## DELETE 删除相册\r\n\r\nDELETE /albums/admin/{id}\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| id  | path | integer(int32) | 是   | id  |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdgetPhotosUsingGET\"></a>\r\n\r\n## GET 根据ID查询照片\r\n\r\nGET /albums/photos/{id}\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| id  | path | integer(int32) | 是   | id  |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdgetPhotosUsingGET_1\"></a>\r\n\r\n## GET 分页查询相册中的照片\r\n\r\nGET /albums/{album_id}/page/{page}\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| album_id | path | integer(int32) | 是   | album_id |\r\n| page | path | integer(int32) | 是   | page |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdgetAlbumsUsingGET\"></a>\r\n\r\n## GET 根据ID查询相册\r\n\r\nGET /albums/{id}\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| id  | path | integer(int32) | 是   | id  |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n# 博客管理接口\r\n\r\n<a id=\"opIdsaveBlogUsingPOST\"></a>\r\n\r\n## POST 管理员添加博客\r\n\r\nPOST /blogs/admin\r\n\r\n> Body 请求参数\r\n\r\n    first_img: string\r\n    \r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| blog_comment | query | boolean | 否   | 是否开启评论 |\r\n| blog_content | query | string | 否   | 内容  |\r\n| blog_description | query | string | 否   | 描述  |\r\n| blog_first_img | query | string | 否   | 首图地址 |\r\n| blog_id | query | integer(int32) | 否   | 博客ID |\r\n| blog_public | query | boolean | 否   | 是否公开 |\r\n| blog_recommend | query | boolean | 否   | 是否推荐 |\r\n| blog_release | query | boolean | 否   | 是否发布 |\r\n| blog_title | query | string | 否   | 标题  |\r\n| blog_update_time | query | string(date-time) | 否   | 更新时间 |\r\n| blog_views | query | integer(int64) | 否   | 查看次数 |\r\n| tags | query | array[integer] | 否   | 关联标签ID列表 |\r\n| user_id | query | integer(int32) | 否   | 关联用户ID |\r\n| token | header | string | 否   | 令牌  |\r\n| body | body | object | 否   | none |\r\n| » first_img | body | string(binary) | 否   | 首页图片文件 |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdpostImgUsingPOST\"></a>\r\n\r\n## POST 管理员上传文章内图片\r\n\r\nPOST /blogs/admin/img\r\n\r\n> Body 请求参数\r\n\r\n    content_img: string\r\n    \r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| token | header | string | 否   | 令牌  |\r\n| body | body | object | 否   | none |\r\n| » content_img | body | string(binary) | 否   | 内容图片文件 |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIddeleteImgUsingDELETE\"></a>\r\n\r\n## DELETE 管理员删除文章内图片\r\n\r\nDELETE /blogs/admin/img/{imgName}\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| imgName | path | string | 是   | 图片名称 |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdadminGetBlogUsingGET\"></a>\r\n\r\n## GET 管理员获取所有博客\r\n\r\nGET /blogs/admin/page/{page}\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| page | path | integer(int32) | 是   | 页码  |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdadminGetBlogByIdUsingGET\"></a>\r\n\r\n## GET 管理员根据ID获取博客\r\n\r\nGET /blogs/admin/{id}\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| id  | path | integer(int32) | 是   | 博客ID |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdputBlogUsingPUT\"></a>\r\n\r\n## PUT 管理员修改博客\r\n\r\nPUT /blogs/admin/{id}\r\n\r\n> Body 请求参数\r\n\r\n    first_img: string\r\n    \r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| id  | path | integer(int32) | 是   | 博客ID |\r\n| blog_comment | query | boolean | 否   | 是否开启评论 |\r\n| blog_content | query | string | 否   | 内容  |\r\n| blog_description | query | string | 否   | 描述  |\r\n| blog_first_img | query | string | 否   | 首图地址 |\r\n| blog_id | query | integer(int32) | 否   | 博客ID |\r\n| blog_public | query | boolean | 否   | 是否公开 |\r\n| blog_recommend | query | boolean | 否   | 是否推荐 |\r\n| blog_release | query | boolean | 否   | 是否发布 |\r\n| blog_title | query | string | 否   | 标题  |\r\n| blog_update_time | query | string(date-time) | 否   | 更新时间 |\r\n| blog_views | query | integer(int64) | 否   | 查看次数 |\r\n| tags | query | array[integer] | 否   | 关联标签ID列表 |\r\n| user_id | query | integer(int32) | 否   | 关联用户ID |\r\n| token | header | string | 否   | 令牌  |\r\n| body | body | object | 否   | none |\r\n| » first_img | body | string(binary) | 否   | 首页图片文件 |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIddeleteBlogUsingDELETE\"></a>\r\n\r\n## DELETE 管理员删除博客\r\n\r\nDELETE /blogs/admin/{id}\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| id  | path | integer(int32) | 是   | 博客ID |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdgetBlogUsingGET\"></a>\r\n\r\n## GET 获取所有博客\r\n\r\nGET /blogs/page/{page}\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| page | path | integer(int32) | 是   | 页码  |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | 成功获取博客列表 | [AjaxResponse](#schemaajaxresponse) |\r\n| 404 | [Not Found](https://tools.ietf.org/html/rfc7231#section-6.5.4) | 超出范围 | Inline |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdgetBlogRecommendUsingGET\"></a>\r\n\r\n## GET 获取推荐博客\r\n\r\nGET /blogs/recommend\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdgetBlogByIdUsingGET\"></a>\r\n\r\n## GET 根据ID获取博客\r\n\r\nGET /blogs/{id}\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| id  | path | integer(int32) | 是   | 博客ID |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n# 评论管理\r\n\r\n<a id=\"opIdpostCommentUsingPOST\"></a>\r\n\r\n## POST 添加评论\r\n\r\nPOST /comment/\r\n\r\n> Body 请求参数\r\n\r\n    {\r\n      \"adminComment\": true,\r\n      \"blogId\": 0,\r\n      \"commentContent\": \"string\",\r\n      \"commentCreateTime\": \"2019-08-24T14:15:22Z\",\r\n      \"commentEmail\": \"string\",\r\n      \"commentId\": 0,\r\n      \"commentNickname\": \"string\"\r\n    }\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| token | header | string | 否   | 令牌  |\r\n| body | body | any | 否   | none |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdputCommentUsingPUT\"></a>\r\n\r\n## PUT 修改评论\r\n\r\nPUT /comment/admin\r\n\r\n> Body 请求参数\r\n\r\n    {\r\n      \"adminComment\": true,\r\n      \"blogId\": 0,\r\n      \"commentContent\": \"string\",\r\n      \"commentCreateTime\": \"2019-08-24T14:15:22Z\",\r\n      \"commentEmail\": \"string\",\r\n      \"commentId\": 0,\r\n      \"commentNickname\": \"string\"\r\n    }\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| token | header | string | 否   | 令牌  |\r\n| body | body | any | 否   | none |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIddeleteCommentUsingDELETE\"></a>\r\n\r\n## DELETE 删除评论\r\n\r\nDELETE /comment/admin/{id}\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| id  | path | integer(int32) | 是   | 评论ID |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdgetCommentUsingGET\"></a>\r\n\r\n## GET 根据博客ID获取评论\r\n\r\nGET /comment/{id}\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| id  | path | integer(int32) | 是   | 博客ID |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n# 用户登录接口\r\n\r\n<a id=\"opIdloginUsingPOST\"></a>\r\n\r\n## POST 用户登录\r\n\r\nPOST /login\r\n\r\n用户通过用户名和密码登录\r\n\r\n> Body 请求参数\r\n\r\n    {\r\n      \"property1\": \"string\",\r\n      \"property2\": \"string\"\r\n    }\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| token | header | string | 否   | 令牌  |\r\n| body | body | object | 否   | none |\r\n| » **additionalProperties** | body | string | 否   | none |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n# 搜索接口\r\n\r\n<a id=\"opIdgetAdminBlogUsingGET\"></a>\r\n\r\n## GET 管理员获取博客列表\r\n\r\nGET /search/admin/{kw}/{page}\r\n\r\n管理员根据关键词和页码获取博客列表\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| kw  | path | string | 是   | kw  |\r\n| page | path | integer(int32) | 是   | page |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdgetBlogUsingGET_1\"></a>\r\n\r\n## GET 获取博客列表\r\n\r\nGET /search/{kw}/{page}\r\n\r\n根据关键词和页码获取博客列表\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| kw  | path | string | 是   | kw  |\r\n| page | path | integer(int32) | 是   | page |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n# 类别管理接口\r\n\r\n<a id=\"opIdgetTypeUsingGET\"></a>\r\n\r\n## GET 查询所有Type\r\n\r\nGET /types\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdgetAllTypeTagUsingGET\"></a>\r\n\r\n## GET 查询所有Type和Tag\r\n\r\nGET /types/admin\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdpostTypeUsingPOST\"></a>\r\n\r\n## POST 添加新的Type\r\n\r\nPOST /types/admin\r\n\r\n> Body 请求参数\r\n\r\n    {\r\n      \"typeParentId\": 0,\r\n      \"typeTagId\": 1,\r\n      \"typeTagLevel\": 1,\r\n      \"typeTagName\": \"科技\"\r\n    }\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| token | header | string | 否   | 令牌  |\r\n| body | body | any | 否   | none |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdputTypeUsingPUT\"></a>\r\n\r\n## PUT 修改Type信息\r\n\r\nPUT /types/admin\r\n\r\n> Body 请求参数\r\n\r\n    {\r\n      \"typeParentId\": 0,\r\n      \"typeTagId\": 1,\r\n      \"typeTagLevel\": 1,\r\n      \"typeTagName\": \"科技\"\r\n    }\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| token | header | string | 否   | 令牌  |\r\n| body | body | any | 否   | none |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdgetAllTypeTagByPageUsingGET\"></a>\r\n\r\n## GET 分页查询所有Type和Tag\r\n\r\nGET /types/admin/page/{page}\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| page | path | integer(int32) | 是   | 页码  |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIddeleteTypeUsingDELETE\"></a>\r\n\r\n## DELETE 删除指定ID的Type\r\n\r\nDELETE /types/admin/{id}\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| id  | path | integer(int32) | 是   | Type ID |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n<a id=\"opIdgetBlogByTagUsingGET\"></a>\r\n\r\n## GET 根据标签查询文章\r\n\r\nGET /types/tags/{id}\r\n\r\n### 请求参数\r\n\r\n| 名称  | 位置  | 类型  | 必选  | 说明  |\r\n| --- | --- | --- | --- | --- |\r\n| id  | path | integer(int32) | 是   | 标签ID |\r\n| token | header | string | 否   | 令牌  |\r\n\r\n> 返回示例\r\n\r\n> 200 Response\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n\r\n### 返回结果\r\n\r\n| 状态码 | 状态码含义 | 说明  | 数据模型 |\r\n| --- | --- | --- | --- |\r\n| 200 | [OK](https://tools.ietf.org/html/rfc7231#section-6.3.1) | OK  | [AjaxResponse](#schemaajaxresponse) |\r\n| 500 | [Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1) | 服务器内部错误 | Inline |\r\n\r\n### 返回数据结构\r\n\r\n# 数据模型\r\n\r\n<h2 id=\"tocS_照片对象\">照片对象</h2>\r\n\r\n<a id=\"schema照片对象\"></a><a id=\"schema_照片对象\"></a><a id=\"tocS照片对象\"></a><a id=\"tocs照片对象\"></a>\r\n\r\n    {\r\n      \"albums_tag\": 1,\r\n      \"photo_filming_time\": \"2023-07-15\",\r\n      \"photo_id\": 1,\r\n      \"photo_introduction\": \"A wonderful summer vacation in Hawaii.\",\r\n      \"photo_name\": \"Summer Vacation\",\r\n      \"photo_save_name\": \"summer_vacation.jpg\"\r\n    }\r\n    \r\n\r\n照片对象\r\n\r\n### 属性\r\n\r\n| 名称  | 类型  | 必选  | 约束  | 中文名 | 说明  |\r\n| --- | --- | --- | --- | --- | --- |\r\n| albums_tag | integer(int32) | false | none |     | 所属二级相册ID |\r\n| photo_filming_time | string(date-time) | false | none |     | 拍摄时间 |\r\n| photo_id | integer(int32) | false | none |     | 照片ID |\r\n| photo_introduction | string | false | none |     | 照片简介 |\r\n| photo_name | string | false | none |     | 照片名 |\r\n| photo_save_name | string | false | none |     | 保存文件名 |\r\n\r\n<h2 id=\"tocS_博客评论\">博客评论</h2>\r\n\r\n<a id=\"schema博客评论\"></a><a id=\"schema_博客评论\"></a><a id=\"tocS博客评论\"></a><a id=\"tocs博客评论\"></a>\r\n\r\n    {\r\n      \"adminComment\": true,\r\n      \"blogId\": 0,\r\n      \"commentContent\": \"string\",\r\n      \"commentCreateTime\": \"2019-08-24T14:15:22Z\",\r\n      \"commentEmail\": \"string\",\r\n      \"commentId\": 0,\r\n      \"commentNickname\": \"string\"\r\n    }\r\n    \r\n\r\n博客评论\r\n\r\n### 属性\r\n\r\n| 名称  | 类型  | 必选  | 约束  | 中文名 | 说明  |\r\n| --- | --- | --- | --- | --- | --- |\r\n| adminComment | boolean | false | none |     | 是否管理员 |\r\n| blogId | integer(int32) | false | none |     | 博客ID |\r\n| commentContent | string | false | none |     | 评论内容 |\r\n| commentCreateTime | string(date-time) | false | none |     | 评论时间 |\r\n| commentEmail | string | false | none |     | 评论者邮箱 |\r\n| commentId | integer(int32) | false | none |     | 评论ID |\r\n| commentNickname | string | false | none |     | 评论者昵称 |\r\n\r\n<h2 id=\"tocS_分类实体类\">分类实体类</h2>\r\n\r\n<a id=\"schema分类实体类\"></a><a id=\"schema_分类实体类\"></a><a id=\"tocS分类实体类\"></a><a id=\"tocs分类实体类\"></a>\r\n\r\n    {\r\n      \"typeParentId\": 0,\r\n      \"typeTagId\": 1,\r\n      \"typeTagLevel\": 1,\r\n      \"typeTagName\": \"科技\"\r\n    }\r\n    \r\n\r\n分类实体类\r\n\r\n### 属性\r\n\r\n| 名称  | 类型  | 必选  | 约束  | 中文名 | 说明  |\r\n| --- | --- | --- | --- | --- | --- |\r\n| typeParentId | integer(int32) | false | none |     | 关联的父分类ID |\r\n| typeTagId | integer(int32) | false | none |     | 分类标签ID |\r\n| typeTagLevel | integer(int32) | false | none |     | 分类标签级别 |\r\n| typeTagName | string | false | none |     | 分类标签名 |\r\n\r\n<h2 id=\"tocS_Albums\">Albums</h2>\r\n\r\n<a id=\"schemaalbums\"></a><a id=\"schema_Albums\"></a><a id=\"tocSalbums\"></a><a id=\"tocsalbums\"></a>\r\n\r\n    {\r\n      \"album_cover\": \"http://example.com/cover.jpg\",\r\n      \"album_create_time\": \"2024-07-05T15:19:00Z\",\r\n      \"album_id\": 1,\r\n      \"album_introduction\": \"这是一个很棒的相册\",\r\n      \"album_level\": 1,\r\n      \"album_name\": \"我的相册\",\r\n      \"album_type\": 0\r\n    }\r\n    \r\n\r\nAlbums\r\n\r\n### 属性\r\n\r\n| 名称  | 类型  | 必选  | 约束  | 中文名 | 说明  |\r\n| --- | --- | --- | --- | --- | --- |\r\n| album_cover | string | false | none |     | 相册封面URL |\r\n| album_create_time | string(date-time) | false | none |     | 相册创建时间 |\r\n| album_id | integer(int32) | false | none |     | 相册ID |\r\n| album_introduction | string | false | none |     | 相册简介 |\r\n| album_level | integer(int32) | false | none |     | 相册级别 |\r\n| album_name | string | false | none |     | 相册名 |\r\n| album_type | integer(int32) | false | none |     | 所属一级相册ID |\r\n\r\n<h2 id=\"tocS_AjaxResponse\">AjaxResponse</h2>\r\n\r\n<a id=\"schemaajaxresponse\"></a><a id=\"schema_AjaxResponse\"></a><a id=\"tocSajaxresponse\"></a><a id=\"tocsajaxresponse\"></a>\r\n\r\n    {\r\n      \"code\": 0,\r\n      \"data\": {},\r\n      \"message\": \"string\",\r\n      \"other\": \"string\"\r\n    }\r\n    \r\n\r\nAjaxResponse\r\n\r\n### 属性\r\n\r\n| 名称  | 类型  | 必选  | 约束  | 中文名 | 说明  |\r\n| --- | --- | --- | --- | --- | --- |\r\n| code | integer(int32) | false | none |     | none |\r\n| data | object | false | none |     | none |\r\n| message | string | false | none |     | none |\r\n| other | string | false | none |     | none |\r\n\r\n<h2 id=\"tocS_Tag\">Tag</h2>\r\n\r\n<a id=\"schematag\"></a><a id=\"schema_Tag\"></a><a id=\"tocStag\"></a><a id=\"tocstag\"></a>\r\n\r\n    {\r\n      \"id\": 1,\r\n      \"name\": \"string\"\r\n    }\r\n    \r\n\r\n### 属性\r\n\r\n| 名称  | 类型  | 必选  | 约束  | 中文名 | 说明  |\r\n| --- | --- | --- | --- | --- | --- |\r\n| id  | integer(int64) | false | none |     | 标签ID编号 |\r\n| name | string | false | none |     | 标签名称 |\r\n\r\n<h2 id=\"tocS_Category\">Category</h2>\r\n\r\n<a id=\"schemacategory\"></a><a id=\"schema_Category\"></a><a id=\"tocScategory\"></a><a id=\"tocscategory\"></a>\r\n\r\n    {\r\n      \"id\": 1,\r\n      \"name\": \"string\"\r\n    }\r\n    \r\n\r\n### 属性\r\n\r\n| 名称  | 类型  | 必选  | 约束  | 中文名 | 说明  |\r\n| --- | --- | --- | --- | --- | --- |\r\n| id  | integer(int64) | false | none |     | 分组ID编号 |\r\n| name | string | false | none |     | 分组名称 |\r\n\r\n<h2 id=\"tocS_Pet\">Pet</h2>\r\n\r\n<a id=\"schemapet\"></a><a id=\"schema_Pet\"></a><a id=\"tocSpet\"></a><a id=\"tocspet\"></a>\r\n\r\n    {\r\n      \"id\": 1,\r\n      \"category\": {\r\n        \"id\": 1,\r\n        \"name\": \"string\"\r\n      },\r\n      \"name\": \"doggie\",\r\n      \"photoUrls\": [\r\n        \"string\"\r\n      ],\r\n      \"tags\": [\r\n        {\r\n          \"id\": 1,\r\n          \"name\": \"string\"\r\n        }\r\n      ],\r\n      \"status\": \"available\"\r\n    }\r\n    \r\n\r\n### 属性\r\n\r\n| 名称  | 类型  | 必选  | 约束  | 中文名 | 说明  |\r\n| --- | --- | --- | --- | --- | --- |\r\n| id  | integer(int64) | true | none |     | 宠物ID编号 |\r\n| category | [Category](#schemacategory) | true | none |     | 分组  |\r\n| name | string | true | none |     | 名称  |\r\n| photoUrls | [string] | true | none |     | 照片URL |\r\n| tags | [[Tag](#schematag)] | true | none |     | 标签  |\r\n| status | string | true | none |     | 状态  |\r\n\r\n#### 枚举值\r\n\r\n| 属性  | 值   |\r\n| --- | --- |\r\n| status | available |\r\n| status | pending |\r\n| status | sold |','TwoDots-Blog  的接口文档','2024-07-06',82,_binary '',_binary '',_binary '',_binary '','f3651531-6f38-4380-a97c-38b76de6ebd9.jpg',1),(26,'test','test','test','2024-07-06',0,_binary '\0',_binary '',_binary '\0',_binary '\0','c0bc23df-bec5-4ef1-bee1-aeaade15ce70.jpg',1);
/*!40000 ALTER TABLE `blogs` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `photos`
--

DROP TABLE IF EXISTS `photos`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `photos` (
  `photo_id` int NOT NULL AUTO_INCREMENT COMMENT '照片ID',
  `photo_name` varchar(50) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '照片原文件名',
  `photo_introduction` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '照片简介',
  `photo_filming_time` datetime DEFAULT NULL COMMENT '拍摄时间',
  `albums_tag` int DEFAULT NULL COMMENT '所属二级相册',
  `photo_save_name` varchar(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '照片保存的名称',
  PRIMARY KEY (`photo_id`) USING BTREE,
  KEY `photo_tag` (`albums_tag`) USING BTREE,
  CONSTRAINT `photos_ibfk_1` FOREIGN KEY (`albums_tag`) REFERENCES `albums` (`album_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=73 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `photos`
--

LOCK TABLES `photos` WRITE;
/*!40000 ALTER TABLE `photos` DISABLE KEYS */;
INSERT INTO `photos` VALUES (1,'z','z','2024-07-06 21:16:48',20,'f3651531-6f38-4380-a97c-38b76de6ebd9.jpg'),(71,'37f84b5c-8db4-4de0-b9d5-2affbb4bdc03','753191e8-8c7a-4997-b530-1adfdea3a5d4',NULL,25,'44b2b829-221c-45e6-80a1-f8d99c99ef2c.jpg'),(72,'83d5fa41-448e-414e-8898-83cbdef78931','a115572e-8eef-4fc9-bc59-8af5a56a7999',NULL,25,'482b18f0-ce78-4b0f-a88a-3ae87e3b8481.jpg');
/*!40000 ALTER TABLE `photos` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `types`
--

DROP TABLE IF EXISTS `types`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `types` (
  `type_tag_id` int NOT NULL AUTO_INCREMENT COMMENT '分类_标签ID',
  `type_tag_name` varchar(50) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '分类_标签名',
  `type_parent_id` int NOT NULL COMMENT '关联的父分类ID',
  `type_tag_level` int NOT NULL COMMENT '分类_标签级别',
  PRIMARY KEY (`type_tag_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `types`
--

LOCK TABLES `types` WRITE;
/*!40000 ALTER TABLE `types` DISABLE KEYS */;
INSERT INTO `types` VALUES (1,'JAVA',0,0),(2,'GO',0,0),(3,'VUE2',0,0),(4,'语言基础',1,1),(5,'杂项',0,0),(6,'接口',5,1);
/*!40000 ALTER TABLE `types` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user`
--

DROP TABLE IF EXISTS `user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `user` (
  `user_id` int NOT NULL AUTO_INCREMENT COMMENT '用户ID',
  `user_name` varchar(50) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '用户名',
  `user_password` varchar(50) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '用户密码',
  `user_email` varchar(50) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '用户邮箱',
  `user_avatar` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL COMMENT '用户头像地址',
  `user_group` int NOT NULL COMMENT '用户组',
  PRIMARY KEY (`user_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user`
--

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;
INSERT INTO `user` VALUES (1,'wsscg','8633D9CC6C5F4FE77EFE52EF44BF8FA5','931305137@qq.com',NULL,1);
/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2024-07-07 13:53:13
